#!/usr/bin/env python3
# NOTE: This is a Python script even though the filename is "generate-sheet.svg".
# It reads the per-glyph SVGs in sketches/ (generated by tools/generate-svg.py)
# and writes a combined glyph sheet to sketches/sheet.svg.
#
# Updated: includes digits 0–9.

from __future__ import annotations

import argparse
import sys
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Optional, Tuple, List


# -----------------------------
# Metrics must match generate-svg.py
# -----------------------------
@dataclass(frozen=True)
class Metrics:
    H: int = 1000
    BASE: float = 780.0
    CAP_TOP: float = 40.0

    CAP_W: float = 700.0
    LC_W: float = 600.0

    XH: float = 440.0  # baseline -> xheight distance

    @property
    def CAP_MID(self) -> float:
        return (self.CAP_TOP + self.BASE) / 2.0

    @property
    def X_TOP(self) -> float:
        return self.BASE - self.XH

    @property
    def X_MID(self) -> float:
        return (self.X_TOP + self.BASE) / 2.0

    @property
    def CAP_H(self) -> float:
        return self.BASE - self.CAP_TOP

    @property
    def DESC_END(self) -> float:
        return float(self.H - 30)


def fmt(x: float) -> str:
    return f"{x:.3f}"


def codepoint_filename(s: str) -> str:
    cps = [f"u{ord(ch):04x}" for ch in s]  # lowercase u + lowercase hex
    code = "_".join(cps)
    return f"character-{code}.svg"


def parse_glyph_svg(path: Path) -> Optional[Tuple[float, float, str]]:
    """
    Returns (viewbox_w, viewbox_h, path_d) or None if missing/unreadable.
    """
    if not path.exists():
        return None

    try:
        root = ET.parse(path).getroot()
    except Exception as e:
        print(f"[warn] Failed to parse {path}: {e}", file=sys.stderr)
        return None

    ns = {"svg": "http://www.w3.org/2000/svg"}

    vb = root.attrib.get("viewBox", "").strip()
    if vb:
        parts = vb.split()
        if len(parts) == 4:
            _, _, w_s, h_s = parts
            try:
                w = float(w_s)
                h = float(h_s)
            except Exception:
                w, h = 0.0, 0.0
        else:
            w, h = 0.0, 0.0
    else:
        # fallback: width/height
        try:
            w = float(root.attrib.get("width", "0"))
            h = float(root.attrib.get("height", "0"))
        except Exception:
            w, h = 0.0, 0.0

    p = root.find(".//svg:path", ns)
    if p is None:
        p = root.find(".//path")

    d = ""
    if p is not None:
        d = p.attrib.get("d", "") or ""

    return (w, h, d)


def escape_text(s: str) -> str:
    return (
        s.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&apos;")
    )


def svg_glyph_instance(d: str, x_sheet: float, baseline_sheet: float, scale: float, m: Metrics) -> str:
    """
    Places a glyph path so that glyph baseline (y=m.BASE in glyph units) aligns to baseline_sheet.
    """
    if not d.strip():
        return ""

    return (
        f'<g class="glyph" transform="translate({fmt(x_sheet)} {fmt(baseline_sheet)})">\n'
        f'  <g transform="scale({fmt(scale)})">\n'
        f'    <g transform="translate(0 {fmt(-m.BASE)})">\n'
        f'      <path d="{d}" fill="currentColor" fill-rule="evenodd"/>\n'
        f"    </g>\n"
        f"  </g>\n"
        f"</g>\n"
    )


def render_cell(
    *,
    ch: str,
    d: str,
    glyph_w_units: float,
    x_cell: float,
    y_cell: float,
    cell_w: float,
    cell_h: float,
    inner_w_units: float,
    scale: float,
    m: Metrics,
    show_guides: bool,
    label_font_size: float = 14.0,
) -> str:
    # label / header area sizes in sheet units
    label_pad_top = 10.0
    label_h = 18.0
    label_gap = 8.0

    glyph_y0 = y_cell + label_pad_top + label_h + label_gap
    baseline_y = glyph_y0 + m.BASE * scale

    # center glyph inside the inner width (in glyph units)
    x_offset_units = (inner_w_units - glyph_w_units) / 2.0
    x_glyph = x_cell + x_offset_units * scale

    parts: List[str] = []

    parts.append(
        f'<rect class="cell" x="{fmt(x_cell)}" y="{fmt(y_cell)}" '
        f'width="{fmt(cell_w)}" height="{fmt(cell_h)}" rx="14" ry="14"/>'
    )

    parts.append(
        f'<text class="label" x="{fmt(x_cell + 12)}" y="{fmt(y_cell + 24)}" '
        f'font-size="{fmt(label_font_size)}">{escape_text(ch)}</text>'
    )

    if show_guides:
        x0 = x_cell + 10
        x1 = x_cell + cell_w - 10

        y_cap = glyph_y0 + m.CAP_TOP * scale
        y_xh = glyph_y0 + m.X_TOP * scale
        y_base = glyph_y0 + m.BASE * scale
        y_desc = glyph_y0 + m.DESC_END * scale

        parts.append(f'<line class="guide cap" x1="{fmt(x0)}" y1="{fmt(y_cap)}" x2="{fmt(x1)}" y2="{fmt(y_cap)}"/>')
        parts.append(f'<line class="guide xh"  x1="{fmt(x0)}" y1="{fmt(y_xh)}" x2="{fmt(x1)}" y2="{fmt(y_xh)}"/>')
        parts.append(f'<line class="guide base" x1="{fmt(x0)}" y1="{fmt(y_base)}" x2="{fmt(x1)}" y2="{fmt(y_base)}"/>')
        parts.append(f'<line class="guide desc" x1="{fmt(x0)}" y1="{fmt(y_desc)}" x2="{fmt(x1)}" y2="{fmt(y_desc)}"/>')

    parts.append(svg_glyph_instance(d, x_glyph, baseline_y, scale, m).rstrip())

    return "\n".join(p for p in parts if p) + "\n"


def render_wrapped_sample(
    *,
    title: str,
    text: str,
    glyphs: Dict[str, Tuple[float, str]],  # ch -> (w_units, d)
    x: float,
    y: float,
    max_w: float,
    scale: float,
    m: Metrics,
    tracking_units: float = 60.0,
    space_units: float = 240.0,
    line_gap: float = 26.0,
    show_guides: bool = True,
) -> Tuple[str, float]:
    """
    Renders a title and a wrapped text line (word wrap on spaces).
    Returns (svg_fragment, y_after).
    """
    parts: List[str] = []
    if title.strip():
        parts.append(f'<text class="section" x="{fmt(x)}" y="{fmt(y)}">{escape_text(title)}</text>')
        y += 18.0

    words = [w for w in text.strip().split(" ") if w != ""]
    if not words:
        return ("\n".join(parts) + "\n", y)

    baseline = y + m.BASE * scale + 8.0

    def word_width_units(word: str) -> float:
        w = 0.0
        for ch in word:
            if ch in glyphs:
                w += glyphs[ch][0] + tracking_units
        if w > 0:
            w -= tracking_units
        return w

    cur_x_units = 0.0
    line_words: List[str] = []
    lines: List[str] = []

    for w in words:
        w_units = word_width_units(w)
        add_units = w_units if not line_words else (space_units + w_units)
        if (cur_x_units + add_units) * scale > max_w and line_words:
            lines.append(" ".join(line_words))
            line_words = [w]
            cur_x_units = w_units
        else:
            if line_words:
                cur_x_units += space_units + w_units
            else:
                cur_x_units = w_units
            line_words.append(w)
    if line_words:
        lines.append(" ".join(line_words))

    for li, line in enumerate(lines):
        line_baseline = baseline + li * (m.H * scale + line_gap)

        if show_guides:
            x0 = x
            x1 = x + max_w
            y_cap = line_baseline + (m.CAP_TOP - m.BASE) * scale
            y_xh = line_baseline + (m.X_TOP - m.BASE) * scale
            y_desc = line_baseline + (m.DESC_END - m.BASE) * scale
            parts.append(f'<line class="guide cap"  x1="{fmt(x0)}" y1="{fmt(y_cap)}" x2="{fmt(x1)}" y2="{fmt(y_cap)}"/>')
            parts.append(f'<line class="guide xh"   x1="{fmt(x0)}" y1="{fmt(y_xh)}" x2="{fmt(x1)}" y2="{fmt(y_xh)}"/>')
            parts.append(f'<line class="guide base" x1="{fmt(x0)}" y1="{fmt(line_baseline)}" x2="{fmt(x1)}" y2="{fmt(line_baseline)}"/>')
            parts.append(f'<line class="guide desc" x1="{fmt(x0)}" y1="{fmt(y_desc)}" x2="{fmt(x1)}" y2="{fmt(y_desc)}"/>')

        x_units = 0.0
        for ch in line:
            if ch == " ":
                x_units += space_units
                continue
            if ch not in glyphs:
                continue
            w_units, d = glyphs[ch]
            x_sheet = x + x_units * scale
            parts.append(svg_glyph_instance(d, x_sheet, line_baseline, scale, m).rstrip())
            x_units += w_units + tracking_units

    y_after = baseline + len(lines) * (m.H * scale + line_gap) + 30.0
    return ("\n".join(p for p in parts if p) + "\n", y_after)


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--in", dest="in_dir", type=Path, default=Path("sketches"), help="Input dir with per-glyph SVGs")
    ap.add_argument("--out", dest="out_file", type=Path, default=Path("sketches/sheet.svg"), help="Output sheet SVG")
    ap.add_argument("--scale", type=float, default=0.35, help="Scale factor for glyphs on the sheet")
    ap.add_argument("--cols", type=int, default=13, help="Columns for the A–Z / a–z grids")
    ap.add_argument("--pad", type=float, default=90.0, help="Inner horizontal padding in glyph units inside each cell")
    ap.add_argument("--gap", type=float, default=18.0, help="Gap between cells (sheet units)")
    ap.add_argument("--no-guides", action="store_true", help="Disable baseline/cap/x-height/desc guides")
    args = ap.parse_args()

    m = Metrics()
    scale = float(args.scale)
    show_guides = not args.no_guides

    # Load glyph paths for A–Z, a–z, 0–9
    upper: Dict[str, Tuple[float, str]] = {}
    lower: Dict[str, Tuple[float, str]] = {}
    digits: Dict[str, Tuple[float, str]] = {}

    missing: List[str] = []

    def load_char(ch: str, fallback_w: float) -> Tuple[float, str]:
        f = args.in_dir / codepoint_filename(ch)
        parsed = parse_glyph_svg(f)
        if parsed is None:
            missing.append(str(f))
            return (fallback_w, "")
        w, _h, d = parsed
        return (w if w > 0 else fallback_w, d)

    for ch in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
        upper[ch] = load_char(ch, m.CAP_W)

    for ch in "abcdefghijklmnopqrstuvwxyz":
        lower[ch] = load_char(ch, m.LC_W)

    for ch in "0123456789":
        # your digit builder uses CAP_W, so fallback is CAP_W
        digits[ch] = load_char(ch, m.CAP_W)

    max_glyph_w = max(
        [w for w, _ in upper.values()] +
        [w for w, _ in lower.values()] +
        [w for w, _ in digits.values()] +
        [m.CAP_W, m.LC_W]
    )
    inner_w_units = max_glyph_w + 2.0 * float(args.pad)

    # Cell geometry (sheet units)
    label_pad_top = 10.0
    label_h = 18.0
    label_gap = 8.0
    cell_bottom_pad = 22.0

    glyph_area_top = label_pad_top + label_h + label_gap
    cell_w = inner_w_units * scale
    cell_h = glyph_area_top + (m.H * scale) + cell_bottom_pad

    cols = int(args.cols)
    gap = float(args.gap)

    margin = 80.0
    title_h = 56.0
    section_gap = 46.0

    # Compute sheet width (based on the grids; digits will use 10 cells, fits in same width)
    grid_w = cols * cell_w + (cols - 1) * gap
    sheet_w = margin * 2 + grid_w

    parts: List[str] = []

    # Title
    y = margin
    parts.append(f'<text class="title" x="{fmt(margin)}" y="{fmt(y)}">Ligatureluurs — glyph sheet</text>')
    y += title_h

    def render_grid(title: str, glyph_map: Dict[str, Tuple[float, str]], chars: str, y0: float) -> float:
        parts.append(f'<text class="section" x="{fmt(margin)}" y="{fmt(y0)}">{escape_text(title)}</text>')
        y0 += 18.0

        rows = (len(chars) + cols - 1) // cols
        for i, ch in enumerate(chars):
            row = i // cols
            col = i % cols
            x_cell = margin + col * (cell_w + gap)
            y_cell = y0 + row * (cell_h + gap)
            w_units, d = glyph_map.get(ch, (max_glyph_w, ""))
            parts.append(
                render_cell(
                    ch=ch,
                    d=d,
                    glyph_w_units=w_units,
                    x_cell=x_cell,
                    y_cell=y_cell,
                    cell_w=cell_w,
                    cell_h=cell_h,
                    inner_w_units=inner_w_units,
                    scale=scale,
                    m=m,
                    show_guides=show_guides,
                ).rstrip()
            )

        return y0 + rows * cell_h + (rows - 1) * gap

    # Digits first (visually useful)
    y = render_grid("Digits 0–9", digits, "0123456789", y) + section_gap
    # Uppercase grid
    y = render_grid("Uppercase A–Z", upper, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", y) + section_gap
    # Lowercase grid
    y = render_grid("Lowercase a–z", lower, "abcdefghijklmnopqrstuvwxyz", y) + section_gap

    # Samples area
    samples_x = margin
    samples_max_w = sheet_w - margin * 2

    # Mixed glyph map for sample lines (include digits)
    mixed: Dict[str, Tuple[float, str]] = {}
    mixed.update(upper)
    mixed.update(lower)
    mixed.update(digits)

    frag, y = render_wrapped_sample(
        title="Samples",
        text="0123456789  10 11 12 13 14 15 16 17 18 19  20 21 22 23 24 25 26 27 28 29",
        glyphs=mixed,
        x=samples_x,
        y=y,
        max_w=samples_max_w,
        scale=scale,
        m=m,
        tracking_units=52.0,
        space_units=220.0,
        line_gap=24.0,
        show_guides=show_guides,
    )
    parts.append(frag.rstrip())

    frag, y = render_wrapped_sample(
        title="",
        text="Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz",
        glyphs=mixed,
        x=samples_x,
        y=y,
        max_w=samples_max_w,
        scale=scale,
        m=m,
        tracking_units=52.0,
        space_units=220.0,
        line_gap=24.0,
        show_guides=show_guides,
    )
    parts.append(frag.rstrip())

    frag, y = render_wrapped_sample(
        title="",
        text="HAMBURGEFONTSIV  hamburgefontsiv  0123456789",
        glyphs=mixed,
        x=samples_x,
        y=y,
        max_w=samples_max_w,
        scale=scale,
        m=m,
        tracking_units=52.0,
        space_units=260.0,
        line_gap=24.0,
        show_guides=show_guides,
    )
    parts.append(frag.rstrip())

    frag, y = render_wrapped_sample(
        title="",
        text="SPHINX OF BLACK QUARTZ JUDGE MY VOW  2026",
        glyphs=mixed,
        x=samples_x,
        y=y,
        max_w=samples_max_w,
        scale=scale,
        m=m,
        tracking_units=52.0,
        space_units=260.0,
        line_gap=24.0,
        show_guides=show_guides,
    )
    parts.append(frag.rstrip())

    sheet_h = y + margin

    style = """
    .title { font: 700 26px system-ui, -apple-system, Segoe UI, Arial, sans-serif; fill: #111; }
    .section { font: 650 16px system-ui, -apple-system, Segoe UI, Arial, sans-serif; fill: #222; }
    .label { font: 650 14px system-ui, -apple-system, Segoe UI, Arial, sans-serif; fill: #333; }
    .cell { fill: #fff; stroke: #d9d9d9; stroke-width: 1.2; }
    .guide { stroke: #ededed; stroke-width: 1; }
    .guide.base { stroke: #e2e2e2; }
    .guide.cap, .guide.xh, .guide.desc { stroke: #f0f0f0; }
    /* Glyph color via currentColor */
    svg { color: #111; background: #fafafa; }
    """.strip()

    svg = (
        f'<svg xmlns="http://www.w3.org/2000/svg" '
        f'viewBox="0 0 {fmt(sheet_w)} {fmt(sheet_h)}" '
        f'width="{fmt(sheet_w)}" height="{fmt(sheet_h)}">\n'
        f"<style>\n{style}\n</style>\n"
        f"{chr(10).join(parts)}\n"
        f"</svg>\n"
    )

    args.out_file.parent.mkdir(parents=True, exist_ok=True)
    args.out_file.write_text(svg, encoding="utf-8")

    print(f"Wrote sheet: {args.out_file}")

    if missing:
        print(f"[warn] Missing {len(missing)} glyph SVG(s). Run tools/generate-svg.py first.", file=sys.stderr)
        for p in missing[:10]:
            print(f"  - {p}", file=sys.stderr)
        if len(missing) > 10:
            print(f"  ... ({len(missing) - 10} more)", file=sys.stderr)


if __name__ == "__main__":
    main()
