#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
tools/generate-fonts.py

Single entrypoint that builds:

DEFAULT (no args):
  - Variable font (wght axis) -> dist/fonts/ligatureluurs.ttf / .woff / .woff2

It assumes glyph SVGs are generated by:
  tools/generate-svg.py

Why this exists:
- Variable fonts need multiple compatible masters.
- Your glyphs come from Shapely buffered geometry; point counts vary with stroke.
- This script generates 3 SVG masters (thin/regular/bold), resamples contours
  to a fixed point count, builds 3 master TTFs, then merges them via varLib.

If you ever want the old static behavior:
  python tools/generate-fonts.py --static
"""

from __future__ import annotations

import argparse
import math
import re
import sys
import subprocess
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple

from fontTools.fontBuilder import FontBuilder
from fontTools.pens.ttGlyphPen import TTGlyphPen
from fontTools.feaLib.builder import addOpenTypeFeaturesFromString

from fontTools.designspaceLib import AxisDescriptor, DesignSpaceDocument, SourceDescriptor
from fontTools.varLib import build as var_build


# -----------------------------
# Must match your glyph SVG coordinate system
# -----------------------------
@dataclass(frozen=True)
class Metrics:
    UPM: int = 1000
    H: int = 1000
    BASE: float = 780.0
    CAP_TOP: float = 40.0
    XH: float = 440.0  # baseline -> xheight

    @property
    def X_TOP(self) -> float:
        return self.BASE - self.XH

    @property
    def DESC_END(self) -> float:
        return float(self.H - 30)


M = Metrics()

REPO_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_GLYPH_SCRIPT = REPO_ROOT / "tools" / "generate-svg.py"

# Your filename format: character-u0061_u0062.svg
FILENAME_RE = re.compile(r"^character-(?P<codes>u[0-9a-f]+(?:_u[0-9a-f]+)*)\.svg$", re.IGNORECASE)


def run(cmd: List[str]) -> None:
    print(">>", " ".join(str(x) for x in cmd))
    subprocess.run(cmd, check=True)


def parse_codepoints_from_filename(name: str) -> Optional[List[int]]:
    m = FILENAME_RE.match(name)
    if not m:
        return None
    codes = m.group("codes").split("_")
    cps: List[int] = []
    for c in codes:
        if not c.lower().startswith("u"):
            return None
        cps.append(int(c[1:], 16))
    return cps


def glyph_name_for_codepoint(cp: int) -> str:
    if cp <= 0xFFFF:
        return f"uni{cp:04X}"
    return f"u{cp:06X}"


def ligature_name(cps: List[int]) -> str:
    return "lig_" + "_".join(f"{cp:04X}" if cp <= 0xFFFF else f"{cp:06X}" for cp in cps)


def parse_svg_viewbox_and_path(svg_path: Path) -> Tuple[float, float, str]:
    root = ET.parse(svg_path).getroot()
    vb = (root.attrib.get("viewBox") or "").strip()
    if not vb:
        raise ValueError(f"{svg_path.name}: missing viewBox")
    parts = vb.split()
    if len(parts) != 4:
        raise ValueError(f"{svg_path.name}: invalid viewBox {vb!r}")
    vb_w = float(parts[2])
    vb_h = float(parts[3])

    ns = {"svg": "http://www.w3.org/2000/svg"}
    p = root.find(".//svg:path", ns)
    if p is None:
        p = root.find(".//path")
    if p is None:
        return (vb_w, vb_h, "")
    d = p.attrib.get("d", "") or ""
    return (vb_w, vb_h, d)


# -----------------------------
# SVG path parsing (M/L/Z)
# -----------------------------
TOKEN_RE = re.compile(r"[MLZmlz]|-?\d+(?:\.\d+)?")

def parse_svg_d_to_contours(d: str) -> List[List[Tuple[float, float]]]:
    d = d.replace(",", " ")
    tokens = TOKEN_RE.findall(d)
    i = 0
    cmd: Optional[str] = None

    contours: List[List[Tuple[float, float]]] = []
    cur: List[Tuple[float, float]] = []

    def flush_close() -> None:
        nonlocal cur
        if not cur:
            return
        if len(cur) >= 2 and cur[0] == cur[-1]:
            cur = cur[:-1]
        if len(cur) >= 2:
            contours.append(cur)
        cur = []

    def read_pair() -> Tuple[float, float]:
        nonlocal i
        if i + 1 >= len(tokens):
            raise ValueError("Unexpected end of path data")
        x = float(tokens[i]); y = float(tokens[i + 1])
        i += 2
        return (x, y)

    while i < len(tokens):
        t = tokens[i]
        if t.isalpha():
            cmd = t
            i += 1
            if cmd in ("Z", "z"):
                flush_close()
            continue

        if cmd is None:
            raise ValueError("Path data missing command")

        if cmd in ("M", "m"):
            x, y = read_pair()
            flush_close()
            cur = [(x, y)]
            cmd = "L"
            continue

        if cmd in ("L", "l"):
            x, y = read_pair()
            cur.append((x, y))
            continue

        if cmd in ("Z", "z"):
            flush_close()
            continue

        raise ValueError(f"Unsupported SVG path command: {cmd}")

    flush_close()
    return contours


# -----------------------------
# Resampling + normalization (crucial for variable-font compatibility)
# -----------------------------
def _poly_area(pts: List[Tuple[float, float]]) -> float:
    if len(pts) < 3:
        return 0.0
    a = 0.0
    for i in range(len(pts)):
        x1, y1 = pts[i]
        x2, y2 = pts[(i + 1) % len(pts)]
        a += x1 * y2 - x2 * y1
    return 0.5 * a

def _poly_centroid(pts: List[Tuple[float, float]]) -> Tuple[float, float]:
    if not pts:
        return (0.0, 0.0)
    sx = sum(x for x, _ in pts)
    sy = sum(y for _, y in pts)
    n = float(len(pts))
    return (sx / n, sy / n)

def _rotate_to_min_xy(pts: List[Tuple[float, float]]) -> List[Tuple[float, float]]:
    if not pts:
        return pts
    min_i = 0
    min_p = pts[0]
    for i, p in enumerate(pts):
        if (p[0] < min_p[0]) or (p[0] == min_p[0] and p[1] < min_p[1]):
            min_p = p
            min_i = i
    return pts[min_i:] + pts[:min_i]

def _resample_closed_contour(pts: List[Tuple[float, float]], n: int) -> List[Tuple[float, float]]:
    """
    Resample a closed contour to exactly n points, equally spaced by arclength.
    pts must NOT repeat the first point at the end.
    """
    if n <= 0 or len(pts) < 3:
        return pts

    m = len(pts)
    dists = [0.0]
    total = 0.0
    for i in range(m):
        x1, y1 = pts[i]
        x2, y2 = pts[(i + 1) % m]
        seg = math.hypot(x2 - x1, y2 - y1)
        total += seg
        dists.append(total)

    if total == 0.0:
        return pts[:n] if len(pts) >= n else (pts + pts[: max(0, n - len(pts))])

    step = total / float(n)
    out: List[Tuple[float, float]] = []

    edge_i = 0
    for k in range(n):
        target = k * step
        while edge_i < m and dists[edge_i + 1] < target:
            edge_i += 1
        a = dists[edge_i]
        b = dists[edge_i + 1]
        t = 0.0 if b == a else (target - a) / (b - a)
        x1, y1 = pts[edge_i]
        x2, y2 = pts[(edge_i + 1) % m]
        out.append((x1 + (x2 - x1) * t, y1 + (y2 - y1) * t))

    return out

def normalize_contours_to_fontcoords(
    contours_svg: List[List[Tuple[float, float]]],
    baseline_svg: float,
    resample_n: int,
) -> List[List[Tuple[int, int]]]:
    """
    SVG (y down) -> font (y up), baseline at y=0, then:
    - resample each contour to resample_n points
    - rotate startpoint to minimal (x,y)
    - sort contours stably (outer before inner, etc.)
    """
    contours_fc: List[List[Tuple[float, float]]] = []

    for pts in contours_svg:
        if len(pts) < 3:
            continue
        tpts = [(x, baseline_svg - y) for x, y in pts]
        if resample_n > 0:
            tpts = _resample_closed_contour(tpts, resample_n)
        tpts = _rotate_to_min_xy(tpts)
        contours_fc.append(tpts)

    sortable: List[Tuple[float, float, float, List[Tuple[float, float]]]] = []
    for pts in contours_fc:
        area = _poly_area(pts)
        cx, cy = _poly_centroid(pts)
        sortable.append((abs(area), cx, cy, pts))

    sortable.sort(key=lambda t: (-t[0], t[1], t[2]))

    out: List[List[Tuple[int, int]]] = []
    for _abs_area, _cx, _cy, pts in sortable:
        out.append([(int(round(x)), int(round(y))) for x, y in pts])

    return out

def contours_to_ttglyph(
    contours_svg: List[List[Tuple[float, float]]],
    baseline_svg: float,
    resample_n: int,
) -> Tuple[object, Tuple[int, int, int, int], int]:
    """
    Returns (glyph, bbox, num_contours_after_normalization)
    """
    pen = TTGlyphPen(None)
    xmins: List[int] = []
    ymins: List[int] = []
    xmaxs: List[int] = []
    ymaxs: List[int] = []

    contours_fc = normalize_contours_to_fontcoords(contours_svg, baseline_svg, resample_n)

    for pts in contours_fc:
        if len(pts) < 3:
            continue
        p0 = pts[0]
        pen.moveTo(p0)
        xmins.append(p0[0]); xmaxs.append(p0[0])
        ymins.append(p0[1]); ymaxs.append(p0[1])
        for p in pts[1:]:
            pen.lineTo(p)
            xmins.append(p[0]); xmaxs.append(p[0])
            ymins.append(p[1]); ymaxs.append(p[1])
        pen.closePath()

    glyph = pen.glyph()
    if xmins:
        bbox = (min(xmins), min(ymins), max(xmaxs), max(ymaxs))
    else:
        bbox = (0, 0, 0, 0)

    return glyph, bbox, len(contours_fc)


def mean_int(xs: Iterable[int]) -> int:
    xs = list(xs)
    return int(round(sum(xs) / max(1, len(xs))))


def build_ttf_from_svg_dir(
    svg_dir: Path,
    family: str,
    style: str,
    version: str,
    filename_base: str,
    baseline_svg: float,
    linegap: int,
    space_width: int,
    weight_class: int,
    resample: int,
    force_glyph_order_from: Optional[List[str]] = None,
    force_cmap_from: Optional[Dict[int, str]] = None,
    force_liga_from: Optional[List[Tuple[List[str], str]]] = None,
) -> Tuple["fontTools.ttLib.TTFont", List[str], Dict[int, str], List[Tuple[List[str], str]], Dict[str, int]]:
    """
    Build a static master TTF from a directory of character-*.svg files.
    Returns:
      - TTFont
      - glyph_order
      - cmap
      - ligatures list ([componentGlyphNames], ligGlyphName)
      - contour_counts per glyph (for compatibility checking)
    """
    svg_files = sorted(svg_dir.glob("character-*.svg"))
    if not svg_files:
        raise SystemExit(f"[err] No glyph SVGs found in {svg_dir}/character-*.svg")

    glyph_order: List[str] = [".notdef", "space"]
    glyf: Dict[str, object] = {}
    hmtx: Dict[str, Tuple[int, int]] = {}
    cmap: Dict[int, str] = {}
    ligatures: List[Tuple[List[str], str]] = []

    contour_counts: Dict[str, int] = {}

    global_xmin = 0
    global_ymin = 0
    global_xmax = 0
    global_ymax = 0
    have_bbox = False

    widths_for_avg: List[int] = []

    # .notdef
    empty_pen = TTGlyphPen(None)
    glyf[".notdef"] = empty_pen.glyph()
    hmtx[".notdef"] = (int(M.UPM * 0.6), 0)
    contour_counts[".notdef"] = 0

    # space
    space_pen = TTGlyphPen(None)
    glyf["space"] = space_pen.glyph()
    hmtx["space"] = (int(space_width), 0)
    cmap[0x20] = "space"
    contour_counts["space"] = 0

    # First pass: collect glyphs present in this directory
    seen_names: List[str] = []
    per_file: Dict[str, Tuple[List[int], int, str]] = {}  # filename -> (cps, adv_w, d)

    for svg_path in svg_files:
        cps = parse_codepoints_from_filename(svg_path.name)
        if not cps:
            continue
        vb_w, _vb_h, d = parse_svg_viewbox_and_path(svg_path)
        adv_w = int(round(vb_w))
        per_file[svg_path.name] = (cps, adv_w, d)

        if len(cps) == 1:
            gname = glyph_name_for_codepoint(cps[0])
        else:
            gname = ligature_name(cps)

        if gname not in seen_names and gname not in glyph_order:
            seen_names.append(gname)

    # If we are forcing a glyph order (for master consistency), use it.
    if force_glyph_order_from is not None:
        glyph_order = list(force_glyph_order_from)
        # ensure .notdef/space exist
        if ".notdef" not in glyph_order:
            glyph_order.insert(0, ".notdef")
        if "space" not in glyph_order:
            glyph_order.insert(1, "space")
    else:
        glyph_order += seen_names

    # Build glyphs in that order (skipping .notdef/space which already exist)
    for gname in glyph_order:
        if gname in (".notdef", "space"):
            continue

        # Find the file that corresponds to this gname
        # (default workflow: each gname comes from exactly one file)
        found: Optional[Tuple[str, List[int], int, str]] = None
        for fn, (cps, adv_w, d) in per_file.items():
            if (len(cps) == 1 and glyph_name_for_codepoint(cps[0]) == gname) or (len(cps) > 1 and ligature_name(cps) == gname):
                found = (fn, cps, adv_w, d)
                break

        if found is None:
            # Missing in this master: create empty glyph with a reasonable advance width.
            # Use avg width if possible.
            adv = mean_int(widths_for_avg) if widths_for_avg else int(M.UPM * 0.5)
            gp = TTGlyphPen(None)
            glyf[gname] = gp.glyph()
            hmtx[gname] = (adv, 0)
            contour_counts[gname] = 0
            continue

        _fn, cps, adv_w, d = found
        widths_for_avg.append(adv_w)

        contours_svg: List[List[Tuple[float, float]]] = []
        if d.strip():
            try:
                contours_svg = parse_svg_d_to_contours(d)
            except Exception:
                contours_svg = []

        glyph, bbox, ncont = contours_to_ttglyph(contours_svg, baseline_svg=baseline_svg, resample_n=resample)
        glyf[gname] = glyph
        hmtx[gname] = (adv_w, 0)
        contour_counts[gname] = ncont

        # cmap / liga collection
        if force_cmap_from is None and len(cps) == 1:
            cmap[cps[0]] = gname
        if force_liga_from is None and len(cps) > 1:
            comps = [glyph_name_for_codepoint(cp) for cp in cps]
            ligatures.append((comps, gname))

        xMin, yMin, xMax, yMax = bbox
        if not have_bbox:
            global_xmin, global_ymin, global_xmax, global_ymax = xMin, yMin, xMax, yMax
            have_bbox = True
        else:
            global_xmin = min(global_xmin, xMin)
            global_ymin = min(global_ymin, yMin)
            global_xmax = max(global_xmax, xMax)
            global_ymax = max(global_ymax, yMax)

    # If forcing cmap/ligatures, copy them
    if force_cmap_from is not None:
        cmap = dict(force_cmap_from)
    if force_liga_from is not None:
        ligatures = list(force_liga_from)

    # Vertical metrics
    asc = max(int(M.BASE - M.CAP_TOP), global_ymax)
    desc = min(-int(M.DESC_END - M.BASE), global_ymin)  # negative

    fb = FontBuilder(M.UPM, isTTF=True)
    fb.setupGlyphOrder(glyph_order)
    fb.setupGlyf(glyf)
    fb.setupHorizontalMetrics(hmtx)
    fb.setupHorizontalHeader(ascent=asc, descent=desc, lineGap=int(linegap))
    fb.setupMaxp()
    fb.setupPost(formatType=3.0)

    fb.setupHead(
        unitsPerEm=M.UPM,
        fontRevision=float(version),
        xMin=int(global_xmin),
        yMin=int(global_ymin),
        xMax=int(global_xmax),
        yMax=int(global_ymax),
    )

    # IMPORTANT: cmap before OS/2
    fb.setupCharacterMap(cmap)

    xheight = int(round(M.XH))
    capheight = int(round(M.BASE - M.CAP_TOP))
    avg_w = mean_int(widths_for_avg) if widths_for_avg else int(M.UPM * 0.5)

    fb.setupOS2(
        sTypoAscender=asc,
        sTypoDescender=desc,
        sTypoLineGap=int(linegap),
        usWinAscent=max(0, asc),
        usWinDescent=max(0, -desc),
        sxHeight=xheight,
        sCapHeight=capheight,
        xAvgCharWidth=avg_w,
        usWeightClass=int(weight_class),
        usWidthClass=5,
    )

    full_name = f"{family} {style}".strip()
    ps_name = re.sub(r"[^A-Za-z0-9-]", "", full_name.replace(" ", "-"))[:63] or f"{filename_base}-{style}"

    fb.setupNameTable(
        {
            "familyName": family,
            "styleName": style,
            "fullName": full_name,
            "psName": ps_name,
            "version": f"Version {version}",
        }
    )

    font = fb.font

    # Add liga substitutions (only needs to exist in the default master; we also add to all masters for safety)
    if ligatures:
        fea_lines = [
            "languagesystem DFLT dflt;",
            "languagesystem latn dflt;",
            "",
            "feature liga {",
        ]
        added = 0
        for comps, lig in ligatures:
            # Only include if components exist
            if all(c in glyf for c in comps) and lig in glyf:
                fea_lines.append(f"  sub {' '.join(comps)} by {lig};")
                added += 1
        fea_lines.append("} liga;")
        if added:
            addOpenTypeFeaturesFromString(font, "\n".join(fea_lines) + "\n")

    return font, glyph_order, cmap, ligatures, contour_counts


def save_font_with_formats(font, base_path: Path, formats: List[str]) -> None:
    wrote_any = False
    for fmt in formats:
        fmt = fmt.lower()
        if fmt == "ttf":
            out_path = base_path.with_suffix(".ttf")
            font.flavor = None
        elif fmt == "woff":
            out_path = base_path.with_suffix(".woff")
            font.flavor = "woff"
        elif fmt == "woff2":
            out_path = base_path.with_suffix(".woff2")
            font.flavor = "woff2"
        else:
            continue

        try:
            font.save(out_path)
            print(f"Wrote: {out_path}")
            wrote_any = True
        except Exception as e:
            print(f"[warn] Could not write {out_path.name}: {e}", file=sys.stderr)

    if not wrote_any:
        raise SystemExit(1)


def main() -> None:
    ap = argparse.ArgumentParser()

    # Keep your old inputs/outputs so calling "like before" still works.
    ap.add_argument("--in", dest="in_dir", type=Path, default=Path("sketches"))
    ap.add_argument("--out", dest="out_dir", type=Path, default=Path("dist/fonts"))
    ap.add_argument("--family", type=str, default="Ligatureluurs")
    ap.add_argument("--style", type=str, default="Regular")
    ap.add_argument("--version", type=str, default="1.0")
    ap.add_argument("--formats", nargs="+", default=["ttf", "woff", "woff2"], choices=["ttf", "woff", "woff2"])
    ap.add_argument("--filename", type=str, default="ligatureluurs", help="Base filename without extension")
    ap.add_argument("--space-width", type=int, default=300)
    ap.add_argument("--baseline", type=float, default=M.BASE, help="SVG baseline y to map to font y=0")
    ap.add_argument("--linegap", type=int, default=200)

    # Variable-font controls (default ON; --static restores old behavior)
    ap.add_argument("--static", action="store_true", help="Build a single static font from --in (old behavior).")

    ap.add_argument("--glyph-script", type=Path, default=DEFAULT_GLYPH_SCRIPT,
                    help="Path to tools/generate-svg.py (assumed by default).")
    ap.add_argument("--chars", type=str, default="", help="Optional: pass through to glyph generator.")
    ap.add_argument("--resolution", type=int, default=64, help="Pass through to glyph generator.")

    # 3 masters: thin / regular / bold
    ap.add_argument("--strokes", nargs=3, type=float, default=[70.0, 90.0, 120.0],
                    metavar=("THIN", "REG", "BOLD"),
                    help="Stroke widths for the 3 masters.")
    ap.add_argument("--weights", nargs=3, type=int, default=[200, 400, 900],
                    metavar=("THIN", "REG", "BOLD"),
                    help="wght axis values for the 3 masters.")

    ap.add_argument("--resample", type=int, default=192,
                    help="Resample every contour to N points (required for stable interpolation).")
    ap.add_argument("--build-dir", type=Path, default=Path("build/vf"),
                    help="Where master SVGs/TTFs and the designspace are written.")
    ap.add_argument("--no-generate", action="store_true",
                    help="Do NOT call tools/generate-svg.py; assume master SVG dirs already exist in build-dir.")
    args = ap.parse_args()

    out_dir: Path = args.out_dir
    out_dir.mkdir(parents=True, exist_ok=True)
    base_out = out_dir / args.filename

    # -------------------------
    # Static mode (old behavior)
    # -------------------------
    if args.static:
        font, _go, _cmap, _liga, _cc = build_ttf_from_svg_dir(
            svg_dir=args.in_dir,
            family=args.family,
            style=args.style,
            version=args.version,
            filename_base=args.filename,
            baseline_svg=float(args.baseline),
            linegap=int(args.linegap),
            space_width=int(args.space_width),
            weight_class=400,
            resample=0,  # static doesn't need resampling
        )
        save_font_with_formats(font, base_out, args.formats)
        return

    # -------------------------
    # Variable mode (default)
    # -------------------------
    glyph_script: Path = args.glyph_script
    if not glyph_script.exists():
        raise SystemExit(f"[err] Missing glyph generator at: {glyph_script}")

    build_dir: Path = args.build_dir
    build_dir.mkdir(parents=True, exist_ok=True)

    strokes = list(map(float, args.strokes))
    weights = list(map(int, args.weights))
    styles  = ["Thin", "Regular", "Bold"]

    # Master SVG directories
    master_svg_dirs: List[Path] = [build_dir / f"svg-{w}" for w in weights]
    master_ttf_paths: List[Path] = [build_dir / f"master-{w}.ttf" for w in weights]

    # 1) Generate master SVGs (unless disabled)
    if not args.no_generate:
        for svg_dir, stroke in zip(master_svg_dirs, strokes):
            svg_dir.mkdir(parents=True, exist_ok=True)
            cmd = [
                sys.executable, str(glyph_script),
                "--out", str(svg_dir),
                "--stroke", str(stroke),
                "--resolution", str(int(args.resolution)),
            ]
            if args.chars:
                cmd += ["--chars", args.chars]
            run(cmd)

    # 2) Build masters
    #    Force glyph order/cmap/ligatures from the Regular master so all masters match.
    regular_idx = 1

    reg_font, glyph_order, cmap, ligatures, reg_counts = build_ttf_from_svg_dir(
        svg_dir=master_svg_dirs[regular_idx],
        family=args.family,
        style=styles[regular_idx],
        version=args.version,
        filename_base=args.filename,
        baseline_svg=float(args.baseline),
        linegap=int(args.linegap),
        space_width=int(args.space_width),
        weight_class=weights[regular_idx],
        resample=int(args.resample),
    )
    reg_font.save(master_ttf_paths[regular_idx])
    print(f"Wrote master: {master_ttf_paths[regular_idx]}")

    all_counts: List[Dict[str, int]] = [None, reg_counts, None]  # type: ignore

    # Other masters
    for idx in (0, 2):
        f, _go2, _cmap2, _liga2, cc = build_ttf_from_svg_dir(
            svg_dir=master_svg_dirs[idx],
            family=args.family,
            style=styles[idx],
            version=args.version,
            filename_base=args.filename,
            baseline_svg=float(args.baseline),
            linegap=int(args.linegap),
            space_width=int(args.space_width),
            weight_class=weights[idx],
            resample=int(args.resample),
            force_glyph_order_from=glyph_order,
            force_cmap_from=cmap,
            force_liga_from=ligatures,
        )
        f.save(master_ttf_paths[idx])
        print(f"Wrote master: {master_ttf_paths[idx]}")
        all_counts[idx] = cc  # type: ignore

    # 3) Preflight compatibility check (clear error message instead of cryptic varLib blow-ups)
    bad: List[str] = []
    for gname in glyph_order:
        c0 = all_counts[0].get(gname, 0)
        c1 = all_counts[1].get(gname, 0)
        c2 = all_counts[2].get(gname, 0)
        if not (c0 == c1 == c2):
            bad.append(f"{gname}: contours thin/reg/bold = {c0}/{c1}/{c2}")

    if bad:
        print("\n[err] Masters are not interpolatable: some glyphs change contour topology between weights.\n"
              "This is common when strokes merge/separate with Shapely buffering.\n"
              "Fix by narrowing the stroke range (or adjusting glyph construction so joins stay consistent).\n",
              file=sys.stderr)
        for line in bad[:80]:
            print("  -", line, file=sys.stderr)
        if len(bad) > 80:
            print(f"  ... and {len(bad) - 80} more", file=sys.stderr)
        raise SystemExit(2)

    # 4) Write designspace
    ds_path = build_dir / f"{args.filename}.designspace"
    ds = DesignSpaceDocument()

    axis = AxisDescriptor()
    axis.name = "Weight"
    axis.tag = "wght"
    axis.minimum = float(min(weights))
    axis.default = float(weights[regular_idx])
    axis.maximum = float(max(weights))
    ds.addAxis(axis)

    axis_name = axis.name  # <-- IMPORTANT: locations use axis.name, not axis.tag

    for idx, (w, style, ttf_path) in enumerate(zip(weights, styles, master_ttf_paths)):
        src = SourceDescriptor()
        src.name = f"master_{w}"
        src.familyName = args.family
        src.styleName = style
        src.path = str(ttf_path)
        src.location = {axis_name: float(w)}  # <-- FIXED
        if idx == regular_idx:
            src.copyInfo = True
            src.copyLib = True
            src.copyFeatures = True
            src.copyGroups = True
        ds.addSource(src)

    ds.write(ds_path)
    print(f"Wrote designspace: {ds_path}")

    # 5) Build variable font
    vf, _model, _master_ttfs = var_build(str(ds_path))

    # 6) Save VF to dist/fonts/ligatureluurs.{ext} (same filename convention as before)
    save_font_with_formats(vf, base_out, args.formats)


if __name__ == "__main__":
    main()
