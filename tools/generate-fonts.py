#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
tools/generate-fonts.py

Single entrypoint that builds (DEFAULT, no args):
  - Variable font (wght axis) -> dist/fonts/ligatureluurs.ttf / .woff / .woff2
  - CSS bundle -> dist/fonts/ligatureluurs.css (copied from src/style/main.css)

Assumes glyph SVGs are generated by:
  tools/generate-svg.py

Notes:
- Variable fonts need multiple compatible masters.
- Your glyphs come from Shapely buffered geometry; point counts can vary with stroke.
- This script generates 3 SVG masters (thin/regular/bold), resamples contours
  to a fixed point count, then merges masters via fontTools.varLib.

Fixes included:
- Prevent twist/flip glitches by:
  1) Reordering contours in Thin/Bold to match Regular (centroid+area matching)
  2) Aligning each contour's direction + cyclic startpoint to Regular
- Restore/lock improved spacing by:
  - Computing per-glyph (advanceWidth, shiftX) from the Regular master and
    applying those exact values to Thin/Bold.

If you ever want the old static behavior:
  python tools/generate-fonts.py --static
"""

from __future__ import annotations

import argparse
import itertools
import math
import re
import sys
import subprocess
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple

from fontTools.fontBuilder import FontBuilder
from fontTools.pens.ttGlyphPen import TTGlyphPen
from fontTools.feaLib.builder import addOpenTypeFeaturesFromString

from fontTools.designspaceLib import AxisDescriptor, DesignSpaceDocument, SourceDescriptor
from fontTools.varLib import build as var_build


# -----------------------------
# Must match your glyph SVG coordinate system
# -----------------------------
@dataclass(frozen=True)
class Metrics:
    UPM: int = 1000
    H: int = 1000
    BASE: float = 780.0
    CAP_TOP: float = 40.0
    XH: float = 440.0  # baseline -> xheight

    @property
    def X_TOP(self) -> float:
        return self.BASE - self.XH

    @property
    def DESC_END(self) -> float:
        return float(self.H - 30)


M = Metrics()

REPO_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_GLYPH_SCRIPT = REPO_ROOT / "tools" / "generate-svg.py"
DEFAULT_CSS_IN = REPO_ROOT / "src" / "style" / "main.css"

# Your filename format: character-u0061_u0062.svg
FILENAME_RE = re.compile(r"^character-(?P<codes>u[0-9a-f]+(?:_u[0-9a-f]+)*)\.svg$", re.IGNORECASE)


def run(cmd: List[str]) -> None:
    print(">>", " ".join(str(x) for x in cmd))
    subprocess.run(cmd, check=True)


def parse_codepoints_from_filename(name: str) -> Optional[List[int]]:
    m = FILENAME_RE.match(name)
    if not m:
        return None
    codes = m.group("codes").split("_")
    cps: List[int] = []
    for c in codes:
        if not c.lower().startswith("u"):
            return None
        cps.append(int(c[1:], 16))
    return cps


def glyph_name_for_codepoint(cp: int) -> str:
    if cp <= 0xFFFF:
        return f"uni{cp:04X}"
    return f"u{cp:06X}"


def ligature_name(cps: List[int]) -> str:
    return "lig_" + "_".join(f"{cp:04X}" if cp <= 0xFFFF else f"{cp:06X}" for cp in cps)


def parse_svg_viewbox_and_path(svg_path: Path) -> Tuple[float, float, str]:
    root = ET.parse(svg_path).getroot()
    vb = (root.attrib.get("viewBox") or "").strip()
    if not vb:
        raise ValueError(f"{svg_path.name}: missing viewBox")
    parts = vb.split()
    if len(parts) != 4:
        raise ValueError(f"{svg_path.name}: invalid viewBox {vb!r}")
    vb_w = float(parts[2])
    vb_h = float(parts[3])

    ns = {"svg": "http://www.w3.org/2000/svg"}
    p = root.find(".//svg:path", ns)
    if p is None:
        p = root.find(".//path")
    if p is None:
        return (vb_w, vb_h, "")
    d = p.attrib.get("d", "") or ""
    return (vb_w, vb_h, d)


# -----------------------------
# SVG path parsing (M/L/Z)
# -----------------------------
TOKEN_RE = re.compile(r"[MLZmlz]|-?\d+(?:\.\d+)?")

def parse_svg_d_to_contours(d: str) -> List[List[Tuple[float, float]]]:
    d = d.replace(",", " ")
    tokens = TOKEN_RE.findall(d)
    i = 0
    cmd: Optional[str] = None

    contours: List[List[Tuple[float, float]]] = []
    cur: List[Tuple[float, float]] = []

    def flush_close() -> None:
        nonlocal cur
        if not cur:
            return
        if len(cur) >= 2 and cur[0] == cur[-1]:
            cur = cur[:-1]
        if len(cur) >= 3:
            contours.append(cur)
        cur = []

    def read_pair() -> Tuple[float, float]:
        nonlocal i
        if i + 1 >= len(tokens):
            raise ValueError("Unexpected end of path data")
        x = float(tokens[i]); y = float(tokens[i + 1])
        i += 2
        return (x, y)

    while i < len(tokens):
        t = tokens[i]
        if t.isalpha():
            cmd = t
            i += 1
            if cmd in ("Z", "z"):
                flush_close()
            continue

        if cmd is None:
            raise ValueError("Path data missing command")

        if cmd in ("M", "m"):
            x, y = read_pair()
            flush_close()
            cur = [(x, y)]
            cmd = "L"
            continue

        if cmd in ("L", "l"):
            x, y = read_pair()
            cur.append((x, y))
            continue

        if cmd in ("Z", "z"):
            flush_close()
            continue

        raise ValueError(f"Unsupported SVG path command: {cmd}")

    flush_close()
    return contours


# -----------------------------
# Resampling + normalization (for interpolation compatibility)
# -----------------------------
def _poly_area(pts: List[Tuple[float, float]]) -> float:
    if len(pts) < 3:
        return 0.0
    a = 0.0
    for i in range(len(pts)):
        x1, y1 = pts[i]
        x2, y2 = pts[(i + 1) % len(pts)]
        a += x1 * y2 - x2 * y1
    return 0.5 * a

def _poly_centroid(pts: List[Tuple[float, float]]) -> Tuple[float, float]:
    if not pts:
        return (0.0, 0.0)
    sx = sum(x for x, _ in pts)
    sy = sum(y for _, y in pts)
    n = float(len(pts))
    return (sx / n, sy / n)

def _rotate_to_min_xy(pts: List[Tuple[float, float]]) -> List[Tuple[float, float]]:
    if not pts:
        return pts
    min_i = 0
    min_p = pts[0]
    for i, p in enumerate(pts):
        if (p[0] < min_p[0]) or (p[0] == min_p[0] and p[1] < min_p[1]):
            min_p = p
            min_i = i
    return pts[min_i:] + pts[:min_i]

def _resample_closed_contour(pts: List[Tuple[float, float]], n: int) -> List[Tuple[float, float]]:
    """
    Resample a closed contour to exactly n points, equally spaced by arclength.
    pts must NOT repeat the first point at the end.
    """
    if n <= 0 or len(pts) < 3:
        return pts

    m = len(pts)
    dists = [0.0]
    total = 0.0
    for i in range(m):
        x1, y1 = pts[i]
        x2, y2 = pts[(i + 1) % m]
        seg = math.hypot(x2 - x1, y2 - y1)
        total += seg
        dists.append(total)

    if total == 0.0:
        return pts[:n] if len(pts) >= n else (pts + pts[: max(0, n - len(pts))])

    step = total / float(n)
    out: List[Tuple[float, float]] = []

    edge_i = 0
    for k in range(n):
        target = k * step
        while edge_i < m and dists[edge_i + 1] < target:
            edge_i += 1
        a = dists[edge_i]
        b = dists[edge_i + 1]
        t = 0.0 if b == a else (target - a) / (b - a)
        x1, y1 = pts[edge_i]
        x2, y2 = pts[(edge_i + 1) % m]
        out.append((x1 + (x2 - x1) * t, y1 + (y2 - y1) * t))

    return out

def normalize_contours_to_fontcoords(
    contours_svg: List[List[Tuple[float, float]]],
    baseline_svg: float,
    resample_n: int,
) -> List[List[Tuple[int, int]]]:
    """
    SVG (y down) -> font (y up), baseline at y=0, then:
    - resample each contour to resample_n points
    - rotate startpoint to minimal (x,y)
    - sort contours stably (outer before inner, etc.)
    """
    contours_fc: List[List[Tuple[float, float]]] = []

    for pts in contours_svg:
        if len(pts) < 3:
            continue
        # SVG y-down -> font y-up, baseline at y=0
        tpts = [(x, baseline_svg - y) for x, y in pts]
        if resample_n > 0:
            tpts = _resample_closed_contour(tpts, resample_n)
        tpts = _rotate_to_min_xy(tpts)
        contours_fc.append(tpts)

    sortable: List[Tuple[float, float, float, List[Tuple[float, float]]]] = []
    for pts in contours_fc:
        area = _poly_area(pts)
        cx, cy = _poly_centroid(pts)
        sortable.append((abs(area), cx, cy, pts))

    # Sort: largest shapes first, then left-to-right, then top-to-bottom (y up)
    sortable.sort(key=lambda t: (-t[0], t[1], t[2]))

    out: List[List[Tuple[int, int]]] = []
    for _abs_area, _cx, _cy, pts in sortable:
        out.append([(int(round(x)), int(round(y))) for x, y in pts])

    return out


# -----------------------------
# Twist/flip prevention:
# - reorder contours in non-reference master to match reference
# - align direction + cyclic startpoint to reference
# -----------------------------
def _cyclic_shift(pts: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]:
    if not pts:
        return pts
    k %= len(pts)
    return pts[k:] + pts[:k]

def _align_contour_to_ref(pts: List[Tuple[int, int]], ref: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    n = len(ref)
    if n == 0 or len(pts) != n:
        return pts

    rx = [p[0] for p in ref]
    ry = [p[1] for p in ref]

    def score(candidate: List[Tuple[int, int]]) -> int:
        s = 0
        for i in range(n):
            dx = candidate[i][0] - rx[i]
            dy = candidate[i][1] - ry[i]
            s += dx * dx + dy * dy
        return s

    best_score: Optional[int] = None
    best_pts: List[Tuple[int, int]] = pts

    for base in (pts, list(reversed(pts))):
        for k in range(n):
            cand = _cyclic_shift(base, k)
            sc = score(cand)
            if best_score is None or sc < best_score:
                best_score = sc
                best_pts = cand

    return best_pts

def _contour_signature(pts: List[Tuple[int, int]]) -> Tuple[float, float, float]:
    fpts = [(float(x), float(y)) for x, y in pts]
    a = abs(_poly_area(fpts))
    cx, cy = _poly_centroid(fpts)
    return (a, cx, cy)

def reorder_contours_to_reference(
    contours: List[List[Tuple[int, int]]],
    ref: List[List[Tuple[int, int]]],
) -> List[List[Tuple[int, int]]]:
    """
    Reorder 'contours' so they correspond to 'ref' as closely as possible.
    Uses permutations for small n (typical glyphs), greedy fallback for larger n.
    """
    n = len(ref)
    if len(contours) != n or n <= 1:
        return contours

    sig_ref = [_contour_signature(c) for c in ref]
    sig_src = [_contour_signature(c) for c in contours]

    def cost(i_ref: int, i_src: int) -> float:
        a0, cx0, cy0 = sig_ref[i_ref]
        a1, cx1, cy1 = sig_src[i_src]
        dxy = (cx1 - cx0) ** 2 + (cy1 - cy0) ** 2
        eps = 1e-6
        ar = (a1 + eps) / (a0 + eps)
        da = (math.log(ar)) ** 2
        return dxy + da * 2000.0

    idxs = list(range(n))

    if n <= 8:
        best_perm = None
        best_score = None
        for perm in itertools.permutations(idxs):
            s = 0.0
            for i_ref, i_src in enumerate(perm):
                s += cost(i_ref, i_src)
            if best_score is None or s < best_score:
                best_score = s
                best_perm = perm
        assert best_perm is not None
        return [contours[i] for i in best_perm]

    remaining = set(idxs)
    out: List[List[Tuple[int, int]]] = []
    for i_ref in idxs:
        best_i = None
        best_c = None
        for i_src in list(remaining):
            c = cost(i_ref, i_src)
            if best_c is None or c < best_c:
                best_c = c
                best_i = i_src
        remaining.remove(best_i)  # type: ignore
        out.append(contours[best_i])  # type: ignore
    return out

def align_contours_to_reference(
    contours: List[List[Tuple[int, int]]],
    ref: List[List[Tuple[int, int]]],
) -> List[List[Tuple[int, int]]]:
    if len(contours) != len(ref):
        return contours

    # 1) reorder contours to match reference (fixes multi-contour glyphs like B)
    contours = reorder_contours_to_reference(contours, ref)

    # 2) align each contour direction + startpoint
    out: List[List[Tuple[int, int]]] = []
    for pts, rpts in zip(contours, ref):
        if len(pts) != len(rpts):
            out.append(pts)
        else:
            out.append(_align_contour_to_ref(pts, rpts))
    return out


# -----------------------------
# Spacing helpers
# -----------------------------
def bbox_from_contours(contours: List[List[Tuple[int, int]]]) -> Tuple[int, int, int, int]:
    xs: List[int] = []
    ys: List[int] = []
    for pts in contours:
        for x, y in pts:
            xs.append(x)
            ys.append(y)
    if not xs:
        return (0, 0, 0, 0)
    return (min(xs), min(ys), max(xs), max(ys))

def translate_contours(contours: List[List[Tuple[int, int]]], dx: int, dy: int = 0) -> List[List[Tuple[int, int]]]:
    if dx == 0 and dy == 0:
        return contours
    return [[(x + dx, y + dy) for (x, y) in pts] for pts in contours]


def mean_int(xs: Iterable[int]) -> int:
    xs = list(xs)
    return int(round(sum(xs) / max(1, len(xs))))


def build_ttf_from_svg_dir(
    svg_dir: Path,
    family: str,
    style: str,
    version: str,
    filename_base: str,
    baseline_svg: float,
    linegap: int,
    space_width: int,
    weight_class: int,
    resample: int,
    force_glyph_order_from: Optional[List[str]] = None,
    force_cmap_from: Optional[Dict[int, str]] = None,
    force_liga_from: Optional[List[Tuple[List[str], str]]] = None,
    # Twist/flip fix:
    align_contours_to: Optional[Dict[str, List[List[Tuple[int, int]]]]] = None,
    collect_ref_contours_out: Optional[Dict[str, List[List[Tuple[int, int]]]]] = None,
    # Spacing plan:
    force_spacing_plan: Optional[Dict[str, Tuple[int, int]]] = None,   # gname -> (shift_x, adv_w)
    collect_spacing_plan_out: Optional[Dict[str, Tuple[int, int]]] = None,
    lsb_pad: int = 55,
    rsb_pad: int = 55,
) -> Tuple["fontTools.ttLib.TTFont", List[str], Dict[int, str], List[Tuple[List[str], str]], Dict[str, int]]:
    """
    Build a static master TTF from a directory of character-*.svg files.
    Returns:
      - TTFont
      - glyph_order
      - cmap
      - ligatures list ([componentGlyphNames], ligGlyphName)
      - contour_counts per glyph (for compatibility checking)
    """
    svg_files = sorted(svg_dir.glob("character-*.svg"))
    if not svg_files:
        raise SystemExit(f"[err] No glyph SVGs found in {svg_dir}/character-*.svg")

    glyph_order: List[str] = [".notdef", "space"]
    glyf: Dict[str, object] = {}
    hmtx: Dict[str, Tuple[int, int]] = {}
    cmap: Dict[int, str] = {}
    ligatures: List[Tuple[List[str], str]] = []

    contour_counts: Dict[str, int] = {}

    global_xmin = 0
    global_ymin = 0
    global_xmax = 0
    global_ymax = 0
    have_bbox = False

    widths_for_avg: List[int] = []

    # .notdef
    empty_pen = TTGlyphPen(None)
    glyf[".notdef"] = empty_pen.glyph()
    hmtx[".notdef"] = (int(M.UPM * 0.6), 0)
    contour_counts[".notdef"] = 0

    # space
    space_pen = TTGlyphPen(None)
    glyf["space"] = space_pen.glyph()
    hmtx["space"] = (int(space_width), 0)
    cmap[0x20] = "space"
    contour_counts["space"] = 0

    # First pass: collect glyphs present in this directory
    seen_names: List[str] = []
    per_file: Dict[str, Tuple[List[int], int, str]] = {}  # filename -> (cps, vb_w(adv_hint), d)

    for svg_path in svg_files:
        cps = parse_codepoints_from_filename(svg_path.name)
        if not cps:
            continue
        vb_w, _vb_h, d = parse_svg_viewbox_and_path(svg_path)
        adv_hint = int(round(vb_w))
        per_file[svg_path.name] = (cps, adv_hint, d)

        if len(cps) == 1:
            gname = glyph_name_for_codepoint(cps[0])
        else:
            gname = ligature_name(cps)

        if gname not in seen_names and gname not in glyph_order:
            seen_names.append(gname)

    # If we are forcing a glyph order (for master consistency), use it.
    if force_glyph_order_from is not None:
        glyph_order = list(force_glyph_order_from)
        if ".notdef" not in glyph_order:
            glyph_order.insert(0, ".notdef")
        if "space" not in glyph_order:
            glyph_order.insert(1, "space")
    else:
        glyph_order += seen_names

    # Build glyphs in that order
    for gname in glyph_order:
        if gname in (".notdef", "space"):
            continue

        found: Optional[Tuple[str, List[int], int, str]] = None
        for fn, (cps, adv_hint, d) in per_file.items():
            if (len(cps) == 1 and glyph_name_for_codepoint(cps[0]) == gname) or (len(cps) > 1 and ligature_name(cps) == gname):
                found = (fn, cps, adv_hint, d)
                break

        if found is None:
            # Missing in this master: empty glyph, but keep spacing consistent if possible.
            gp = TTGlyphPen(None)
            glyf[gname] = gp.glyph()
            contour_counts[gname] = 0

            if force_spacing_plan is not None and gname in force_spacing_plan:
                shift_x, adv_w = force_spacing_plan[gname]
                # For empty glyph, we just keep advance; LSB 0.
                hmtx[gname] = (int(adv_w), 0)
                widths_for_avg.append(int(adv_w))
            else:
                adv = mean_int(widths_for_avg) if widths_for_avg else int(M.UPM * 0.5)
                hmtx[gname] = (int(adv), 0)
                widths_for_avg.append(int(adv))
            continue

        _fn, cps, adv_hint, d = found

        # Parse contours from path
        contours_svg: List[List[Tuple[float, float]]] = []
        if d.strip():
            try:
                contours_svg = parse_svg_d_to_contours(d)
            except Exception:
                contours_svg = []

        contours_fc = normalize_contours_to_fontcoords(contours_svg, baseline_svg=baseline_svg, resample_n=resample)

        # --- Apply spacing plan (from Regular) BEFORE aligning to reference ---
        # This keeps coordinate systems consistent for reorder+phase alignment.
        if force_spacing_plan is not None and gname in force_spacing_plan:
            shift_x, adv_w = force_spacing_plan[gname]
        else:
            # Compute "nice" spacing from Regular: tighten width around ink bbox + pads.
            xMin0, _yMin0, xMax0, _yMax0 = bbox_from_contours(contours_fc)
            ink_w = max(0, xMax0 - xMin0)

            # shift so the leftmost ink starts near x = (some stable left padding)
            shift_x = -xMin0 + int(lsb_pad)

            # advance = ink width + pads (NOT the viewBox width)
            adv_w = int(ink_w + int(lsb_pad) + int(rsb_pad))

            # Avoid absurdly small advances for super-narrow glyphs
            adv_w = max(adv_w, 220)

            if collect_spacing_plan_out is not None:
                collect_spacing_plan_out[gname] = (int(shift_x), int(adv_w))

        contours_fc = translate_contours(contours_fc, int(shift_x), 0)

        # --- Now align to Regular contours (fix twist/flip) ---
        if align_contours_to is not None:
            ref = align_contours_to.get(gname)
            if ref is not None:
                contours_fc = align_contours_to_reference(contours_fc, ref)

        # If this is the reference master, store the shifted contours for later
        if collect_ref_contours_out is not None:
            collect_ref_contours_out[gname] = contours_fc

        # Draw glyph
        pen = TTGlyphPen(None)
        xmins: List[int] = []
        ymins: List[int] = []
        xmaxs: List[int] = []
        ymaxs: List[int] = []

        for pts in contours_fc:
            if len(pts) < 3:
                continue
            p0 = pts[0]
            pen.moveTo(p0)
            xmins.append(p0[0]); xmaxs.append(p0[0])
            ymins.append(p0[1]); ymaxs.append(p0[1])
            for p in pts[1:]:
                pen.lineTo(p)
                xmins.append(p[0]); xmaxs.append(p[0])
                ymins.append(p[1]); ymaxs.append(p[1])
            pen.closePath()

        glyph = pen.glyph()

        if xmins:
            bbox = (min(xmins), min(ymins), max(xmaxs), max(ymaxs))
        else:
            bbox = (0, 0, 0, 0)

        glyf[gname] = glyph
        contour_counts[gname] = len(contours_fc)

        # Horizontal metrics:
        # Use the planned advance width (locked across masters for VF stability).
        # Set LSB to bbox xMin (sensible metrics).
        xMin, yMin, xMax, yMax = bbox
        hmtx[gname] = (int(adv_w), int(xMin))
        widths_for_avg.append(int(adv_w))

        # cmap / liga collection
        if force_cmap_from is None and len(cps) == 1:
            cmap[cps[0]] = gname
        if force_liga_from is None and len(cps) > 1:
            comps = [glyph_name_for_codepoint(cp) for cp in cps]
            ligatures.append((comps, gname))

        if not have_bbox:
            global_xmin, global_ymin, global_xmax, global_ymax = xMin, yMin, xMax, yMax
            have_bbox = True
        else:
            global_xmin = min(global_xmin, xMin)
            global_ymin = min(global_ymin, yMin)
            global_xmax = max(global_xmax, xMax)
            global_ymax = max(global_ymax, yMax)

    # If forcing cmap/ligatures, copy them
    if force_cmap_from is not None:
        cmap = dict(force_cmap_from)
    if force_liga_from is not None:
        ligatures = list(force_liga_from)

    # Vertical metrics
    asc = max(int(M.BASE - M.CAP_TOP), global_ymax)
    desc = min(-int(M.DESC_END - M.BASE), global_ymin)  # negative

    fb = FontBuilder(M.UPM, isTTF=True)
    fb.setupGlyphOrder(glyph_order)
    fb.setupGlyf(glyf)
    fb.setupHorizontalMetrics(hmtx)
    fb.setupHorizontalHeader(ascent=asc, descent=desc, lineGap=int(linegap))
    fb.setupMaxp()
    fb.setupPost(formatType=3.0)

    fb.setupHead(
        unitsPerEm=M.UPM,
        fontRevision=float(version),
        xMin=int(global_xmin),
        yMin=int(global_ymin),
        xMax=int(global_xmax),
        yMax=int(global_ymax),
    )

    # IMPORTANT: cmap before OS/2
    fb.setupCharacterMap(cmap)

    xheight = int(round(M.XH))
    capheight = int(round(M.BASE - M.CAP_TOP))
    avg_w = mean_int(widths_for_avg) if widths_for_avg else int(M.UPM * 0.5)

    fb.setupOS2(
        sTypoAscender=asc,
        sTypoDescender=desc,
        sTypoLineGap=int(linegap),
        usWinAscent=max(0, asc),
        usWinDescent=max(0, -desc),
        sxHeight=xheight,
        sCapHeight=capheight,
        xAvgCharWidth=avg_w,
        usWeightClass=int(weight_class),
        usWidthClass=5,
    )

    full_name = f"{family} {style}".strip()
    ps_name = re.sub(r"[^A-Za-z0-9-]", "", full_name.replace(" ", "-"))[:63] or f"{filename_base}-{style}"

    fb.setupNameTable(
        {
            "familyName": family,
            "styleName": style,
            "fullName": full_name,
            "psName": ps_name,
            "version": f"Version {version}",
        }
    )

    font = fb.font

    # Add liga substitutions (keep in all masters for safety)
    if ligatures:
        fea_lines = [
            "languagesystem DFLT dflt;",
            "languagesystem latn dflt;",
            "",
            "feature liga {",
        ]
        added = 0
        for comps, lig in ligatures:
            if all(c in glyf for c in comps) and lig in glyf:
                fea_lines.append(f"  sub {' '.join(comps)} by {lig};")
                added += 1
        fea_lines.append("} liga;")
        if added:
            addOpenTypeFeaturesFromString(font, "\n".join(fea_lines) + "\n")

    return font, glyph_order, cmap, ligatures, contour_counts


def save_font_with_formats(font, base_path: Path, formats: List[str]) -> None:
    wrote_any = False
    for fmt in formats:
        fmt = fmt.lower()
        if fmt == "ttf":
            out_path = base_path.with_suffix(".ttf")
            font.flavor = None
        elif fmt == "woff":
            out_path = base_path.with_suffix(".woff")
            font.flavor = "woff"
        elif fmt == "woff2":
            out_path = base_path.with_suffix(".woff2")
            font.flavor = "woff2"
        else:
            continue

        try:
            font.save(out_path)
            print(f"Wrote: {out_path}")
            wrote_any = True
        except Exception as e:
            print(f"[warn] Could not write {out_path.name}: {e}", file=sys.stderr)

    if not wrote_any:
        raise SystemExit(1)


def write_css_bundle(out_dir: Path, filename_base: str) -> None:
    out_css = out_dir / f"{filename_base}.css"
    try:
        if DEFAULT_CSS_IN.exists():
            out_css.write_text(DEFAULT_CSS_IN.read_text(encoding="utf-8"), encoding="utf-8")
            print(f"Wrote: {out_css}")
        else:
            print(f"[warn] Missing CSS source: {DEFAULT_CSS_IN}", file=sys.stderr)
    except Exception as e:
        print(f"[warn] Could not write CSS {out_css.name}: {e}", file=sys.stderr)


def main() -> None:
    ap = argparse.ArgumentParser()

    # Keep legacy inputs/outputs working.
    ap.add_argument("--in", dest="in_dir", type=Path, default=Path("sketches"))
    ap.add_argument("--out", dest="out_dir", type=Path, default=Path("dist/fonts"))
    ap.add_argument("--family", type=str, default="Ligatureluurs")
    ap.add_argument("--style", type=str, default="Regular")
    ap.add_argument("--version", type=str, default="1.0")
    ap.add_argument("--formats", nargs="+", default=["ttf", "woff", "woff2"], choices=["ttf", "woff", "woff2"])
    ap.add_argument("--filename", type=str, default="ligatureluurs", help="Base filename without extension")
    ap.add_argument("--space-width", type=int, default=300)
    ap.add_argument("--baseline", type=float, default=M.BASE, help="SVG baseline y to map to font y=0")
    ap.add_argument("--linegap", type=int, default=200)

    # Spacing tuning (applies to Regular; then locked across masters)
    ap.add_argument("--lsb-pad", type=int, default=55, help="Left padding (units) added to ink bbox for spacing plan.")
    ap.add_argument("--rsb-pad", type=int, default=55, help="Right padding (units) added to ink bbox for spacing plan.")

    # Variable-font controls (default ON; --static restores old behavior)
    ap.add_argument("--static", action="store_true", help="Build a single static font from --in (old behavior).")

    ap.add_argument("--glyph-script", type=Path, default=DEFAULT_GLYPH_SCRIPT,
                    help="Path to tools/generate-svg.py (assumed by default).")
    ap.add_argument("--chars", type=str, default="", help="Optional: pass through to glyph generator.")
    ap.add_argument("--resolution", type=int, default=64, help="Pass through to glyph generator.")

    # 3 masters: thin / regular / bold
    ap.add_argument("--strokes", nargs=3, type=float, default=[70.0, 90.0, 120.0],
                    metavar=("THIN", "REG", "BOLD"),
                    help="Stroke widths for the 3 masters.")
    ap.add_argument("--weights", nargs=3, type=int, default=[200, 400, 900],
                    metavar=("THIN", "REG", "BOLD"),
                    help="wght axis values for the 3 masters.")

    ap.add_argument("--resample", type=int, default=192,
                    help="Resample every contour to N points (required for stable interpolation).")
    ap.add_argument("--build-dir", type=Path, default=Path("build/vf"),
                    help="Where master SVGs/TTFs and the designspace are written.")
    ap.add_argument("--no-generate", action="store_true",
                    help="Do NOT call tools/generate-svg.py; assume master SVG dirs already exist in build-dir.")
    args = ap.parse_args()

    out_dir: Path = args.out_dir
    out_dir.mkdir(parents=True, exist_ok=True)
    base_out = out_dir / args.filename

    # -------------------------
    # Static mode (old behavior)
    # -------------------------
    if args.static:
        font, _go, _cmap, _liga, _cc = build_ttf_from_svg_dir(
            svg_dir=args.in_dir,
            family=args.family,
            style=args.style,
            version=args.version,
            filename_base=args.filename,
            baseline_svg=float(args.baseline),
            linegap=int(args.linegap),
            space_width=int(args.space_width),
            weight_class=400,
            resample=0,  # static doesn't need resampling
            lsb_pad=int(args.lsb_pad),
            rsb_pad=int(args.rsb_pad),
        )
        save_font_with_formats(font, base_out, args.formats)
        write_css_bundle(out_dir, args.filename)
        return

    # -------------------------
    # Variable mode (default)
    # -------------------------
    glyph_script: Path = args.glyph_script
    if not glyph_script.exists():
        raise SystemExit(f"[err] Missing glyph generator at: {glyph_script}")

    build_dir: Path = args.build_dir
    build_dir.mkdir(parents=True, exist_ok=True)

    strokes = list(map(float, args.strokes))
    weights = list(map(int, args.weights))
    styles  = ["Thin", "Regular", "Bold"]

    master_svg_dirs: List[Path] = [build_dir / f"svg-{w}" for w in weights]
    master_ttf_paths: List[Path] = [build_dir / f"master-{w}.ttf" for w in weights]

    # 1) Generate master SVGs
    if not args.no_generate:
        for svg_dir, stroke in zip(master_svg_dirs, strokes):
            svg_dir.mkdir(parents=True, exist_ok=True)
            cmd = [
                sys.executable, str(glyph_script),
                "--out", str(svg_dir),
                "--stroke", str(stroke),
                "--resolution", str(int(args.resolution)),
            ]
            if args.chars:
                cmd += ["--chars", args.chars]
            run(cmd)

    # 2) Build masters
    regular_idx = 1  # Regular is the base / default

    # Reference data from Regular:
    ref_contours: Dict[str, List[List[Tuple[int, int]]]] = {}
    spacing_plan: Dict[str, Tuple[int, int]] = {}  # gname -> (shift_x, adv_w)

    reg_font, glyph_order, cmap, ligatures, reg_counts = build_ttf_from_svg_dir(
        svg_dir=master_svg_dirs[regular_idx],
        family=args.family,
        style=styles[regular_idx],
        version=args.version,
        filename_base=args.filename,
        baseline_svg=float(args.baseline),
        linegap=int(args.linegap),
        space_width=int(args.space_width),
        weight_class=weights[regular_idx],
        resample=int(args.resample),
        collect_ref_contours_out=ref_contours,
        collect_spacing_plan_out=spacing_plan,
        lsb_pad=int(args.lsb_pad),
        rsb_pad=int(args.rsb_pad),
    )
    reg_font.save(master_ttf_paths[regular_idx])
    print(f"Wrote master: {master_ttf_paths[regular_idx]}")

    all_counts: List[Dict[str, int]] = [None, reg_counts, None]  # type: ignore

    for idx in (0, 2):
        f, _go2, _cmap2, _liga2, cc = build_ttf_from_svg_dir(
            svg_dir=master_svg_dirs[idx],
            family=args.family,
            style=styles[idx],
            version=args.version,
            filename_base=args.filename,
            baseline_svg=float(args.baseline),
            linegap=int(args.linegap),
            space_width=int(args.space_width),
            weight_class=weights[idx],
            resample=int(args.resample),
            force_glyph_order_from=glyph_order,
            force_cmap_from=cmap,
            force_liga_from=ligatures,
            align_contours_to=ref_contours,
            force_spacing_plan=spacing_plan,
            lsb_pad=int(args.lsb_pad),
            rsb_pad=int(args.rsb_pad),
        )
        f.save(master_ttf_paths[idx])
        print(f"Wrote master: {master_ttf_paths[idx]}")
        all_counts[idx] = cc  # type: ignore

    # 3) Preflight: contour topology must match across masters
    bad: List[str] = []
    for gname in glyph_order:
        c0 = all_counts[0].get(gname, 0)
        c1 = all_counts[1].get(gname, 0)
        c2 = all_counts[2].get(gname, 0)
        if not (c0 == c1 == c2):
            bad.append(f"{gname}: contours thin/reg/bold = {c0}/{c1}/{c2}")

    if bad:
        print(
            "\n[err] Masters are not interpolatable: some glyphs change contour topology between weights.\n"
            "This is common when strokes merge/separate with Shapely buffering.\n"
            "Fix by narrowing the stroke range (or adjusting glyph construction so joins stay consistent).\n",
            file=sys.stderr
        )
        for line in bad[:80]:
            print("  -", line, file=sys.stderr)
        if len(bad) > 80:
            print(f"  ... and {len(bad) - 80} more", file=sys.stderr)
        raise SystemExit(2)

    # 4) Write designspace
    ds_path = build_dir / f"{args.filename}.designspace"
    ds = DesignSpaceDocument()

    axis = AxisDescriptor()
    axis.name = "Weight"
    axis.tag = "wght"
    axis.minimum = float(min(weights))
    axis.default = float(weights[regular_idx])
    axis.maximum = float(max(weights))
    ds.addAxis(axis)

    axis_name = axis.name  # locations use axis.name

    for idx, (w, st, ttf_path) in enumerate(zip(weights, styles, master_ttf_paths)):
        src = SourceDescriptor()
        src.name = f"master_{w}"
        src.familyName = args.family
        src.styleName = st
        src.path = str(ttf_path)
        src.location = {axis_name: float(w)}
        if idx == regular_idx:
            src.copyInfo = True
            src.copyLib = True
            src.copyFeatures = True
            src.copyGroups = True
        ds.addSource(src)

    ds.write(ds_path)
    print(f"Wrote designspace: {ds_path}")

    # 5) Build variable font
    vf, _model, _master_ttfs = var_build(str(ds_path))

    # 6) Save VF to dist/fonts/ligatureluurs.{ext}
    save_font_with_formats(vf, base_out, args.formats)

    # 7) CSS bundle
    write_css_bundle(out_dir, args.filename)


if __name__ == "__main__":
    main()
