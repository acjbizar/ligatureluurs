#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
tools/generate-fonts.py

DEFAULT (no args):
  - Variable font (wght axis) -> dist/fonts/ligatureluurs.ttf / .woff / .woff2
  - CSS bundle copy           -> dist/fonts/ligatureluurs.css  (from src/style/main.css)

Assumes glyph SVGs are generated by:
  tools/generate-svg.py

Why this exists:
- Variable fonts need multiple compatible masters.
- Your glyphs come from Shapely buffered geometry; point counts vary with stroke.
- This script generates 3 SVG masters (thin/regular/bold), resamples contours
  to a fixed point count, builds 3 master TTFs, then merges them via varLib.

Spacing improvements:
- Uses PROPORTIONAL spacing based on each glyphâ€™s outline bbox (not SVG viewBox width).
- For VF stability, metrics are based on MAX outline width across masters (no jitter).

If you ever want the old static behavior:
  python tools/generate-fonts.py --static
"""

from __future__ import annotations

import argparse
import math
import re
import sys
import subprocess
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple

from fontTools.fontBuilder import FontBuilder
from fontTools.pens.ttGlyphPen import TTGlyphPen
from fontTools.feaLib.builder import addOpenTypeFeaturesFromString

from fontTools.designspaceLib import AxisDescriptor, DesignSpaceDocument, SourceDescriptor
from fontTools.varLib import build as var_build


# -----------------------------
# Must match your glyph SVG coordinate system
# -----------------------------
@dataclass(frozen=True)
class Metrics:
    UPM: int = 1000
    H: int = 1000
    BASE: float = 780.0
    CAP_TOP: float = 40.0
    XH: float = 440.0  # baseline -> xheight

    @property
    def X_TOP(self) -> float:
        return self.BASE - self.XH

    @property
    def DESC_END(self) -> float:
        return float(self.H - 30)


M = Metrics()

REPO_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_GLYPH_SCRIPT = REPO_ROOT / "tools" / "generate-svg.py"
SRC_CSS_DEFAULT = REPO_ROOT / "src" / "style" / "main.css"

# character-u0061_u0062.svg
FILENAME_RE = re.compile(r"^character-(?P<codes>u[0-9a-f]+(?:_u[0-9a-f]+)*)\.svg$", re.IGNORECASE)


def run(cmd: List[str]) -> None:
    print(">>", " ".join(str(x) for x in cmd))
    subprocess.run(cmd, check=True)


def write_css_bundle(out_css_path: Path, src_css_path: Path) -> None:
    """
    Copy src/style/main.css -> dist/fonts/<filename>.css
    """
    if not src_css_path.exists():
        print(f"[warn] CSS source not found: {src_css_path} (skipping {out_css_path.name})", file=sys.stderr)
        return
    out_css_path.parent.mkdir(parents=True, exist_ok=True)
    out_css_path.write_text(src_css_path.read_text(encoding="utf-8"), encoding="utf-8")
    print(f"Wrote: {out_css_path}")


def parse_codepoints_from_filename(name: str) -> Optional[List[int]]:
    m = FILENAME_RE.match(name)
    if not m:
        return None
    codes = m.group("codes").split("_")
    cps: List[int] = []
    for c in codes:
        if not c.lower().startswith("u"):
            return None
        cps.append(int(c[1:], 16))
    return cps


def glyph_name_for_codepoint(cp: int) -> str:
    if cp <= 0xFFFF:
        return f"uni{cp:04X}"
    return f"u{cp:06X}"


def ligature_name(cps: List[int]) -> str:
    return "lig_" + "_".join(f"{cp:04X}" if cp <= 0xFFFF else f"{cp:06X}" for cp in cps)


def glyph_name_from_filename(name: str) -> Optional[str]:
    cps = parse_codepoints_from_filename(name)
    if not cps:
        return None
    if len(cps) == 1:
        return glyph_name_for_codepoint(cps[0])
    return ligature_name(cps)


def parse_svg_viewbox_and_path(svg_path: Path) -> Tuple[float, float, str]:
    root = ET.parse(svg_path).getroot()
    vb = (root.attrib.get("viewBox") or "").strip()
    if not vb:
        raise ValueError(f"{svg_path.name}: missing viewBox")
    parts = vb.split()
    if len(parts) != 4:
        raise ValueError(f"{svg_path.name}: invalid viewBox {vb!r}")
    vb_w = float(parts[2])
    vb_h = float(parts[3])

    ns = {"svg": "http://www.w3.org/2000/svg"}
    p = root.find(".//svg:path", ns)
    if p is None:
        p = root.find(".//path")
    if p is None:
        return (vb_w, vb_h, "")
    d = p.attrib.get("d", "") or ""
    return (vb_w, vb_h, d)


# -----------------------------
# SVG path parsing (M/L/Z)
# -----------------------------
TOKEN_RE = re.compile(r"[MLZmlz]|-?\d+(?:\.\d+)?")

def parse_svg_d_to_contours(d: str) -> List[List[Tuple[float, float]]]:
    d = d.replace(",", " ")
    tokens = TOKEN_RE.findall(d)
    i = 0
    cmd: Optional[str] = None

    contours: List[List[Tuple[float, float]]] = []
    cur: List[Tuple[float, float]] = []

    def flush_close() -> None:
        nonlocal cur
        if not cur:
            return
        if len(cur) >= 2 and cur[0] == cur[-1]:
            cur = cur[:-1]
        if len(cur) >= 2:
            contours.append(cur)
        cur = []

    def read_pair() -> Tuple[float, float]:
        nonlocal i
        if i + 1 >= len(tokens):
            raise ValueError("Unexpected end of path data")
        x = float(tokens[i]); y = float(tokens[i + 1])
        i += 2
        return (x, y)

    while i < len(tokens):
        t = tokens[i]
        if t.isalpha():
            cmd = t
            i += 1
            if cmd in ("Z", "z"):
                flush_close()
            continue

        if cmd is None:
            raise ValueError("Path data missing command")

        if cmd in ("M", "m"):
            x, y = read_pair()
            flush_close()
            cur = [(x, y)]
            cmd = "L"
            continue

        if cmd in ("L", "l"):
            x, y = read_pair()
            cur.append((x, y))
            continue

        if cmd in ("Z", "z"):
            flush_close()
            continue

        raise ValueError(f"Unsupported SVG path command: {cmd}")

    flush_close()
    return contours


# -----------------------------
# Resampling + normalization (variable-font compatibility)
# -----------------------------
def _poly_area(pts: List[Tuple[float, float]]) -> float:
    if len(pts) < 3:
        return 0.0
    a = 0.0
    for i in range(len(pts)):
        x1, y1 = pts[i]
        x2, y2 = pts[(i + 1) % len(pts)]
        a += x1 * y2 - x2 * y1
    return 0.5 * a

def _poly_centroid(pts: List[Tuple[float, float]]) -> Tuple[float, float]:
    if not pts:
        return (0.0, 0.0)
    sx = sum(x for x, _ in pts)
    sy = sum(y for _, y in pts)
    n = float(len(pts))
    return (sx / n, sy / n)

def _rotate_to_min_xy(pts: List[Tuple[float, float]]) -> List[Tuple[float, float]]:
    if not pts:
        return pts
    min_i = 0
    min_p = pts[0]
    for i, p in enumerate(pts):
        if (p[0] < min_p[0]) or (p[0] == min_p[0] and p[1] < min_p[1]):
            min_p = p
            min_i = i
    return pts[min_i:] + pts[:min_i]

def _resample_closed_contour(pts: List[Tuple[float, float]], n: int) -> List[Tuple[float, float]]:
    """
    Resample a closed contour to exactly n points, equally spaced by arclength.
    pts must NOT repeat the first point at the end.
    """
    if n <= 0 or len(pts) < 3:
        return pts

    m = len(pts)
    dists = [0.0]
    total = 0.0
    for i in range(m):
        x1, y1 = pts[i]
        x2, y2 = pts[(i + 1) % m]
        seg = math.hypot(x2 - x1, y2 - y1)
        total += seg
        dists.append(total)

    if total == 0.0:
        return pts[:n] if len(pts) >= n else (pts + pts[: max(0, n - len(pts))])

    step = total / float(n)
    out: List[Tuple[float, float]] = []

    edge_i = 0
    for k in range(n):
        target = k * step
        while edge_i < m and dists[edge_i + 1] < target:
            edge_i += 1
        a = dists[edge_i]
        b = dists[edge_i + 1]
        t = 0.0 if b == a else (target - a) / (b - a)
        x1, y1 = pts[edge_i]
        x2, y2 = pts[(edge_i + 1) % m]
        out.append((x1 + (x2 - x1) * t, y1 + (y2 - y1) * t))

    return out

def normalize_contours_to_fontcoords(
    contours_svg: List[List[Tuple[float, float]]],
    baseline_svg: float,
    resample_n: int,
) -> List[List[Tuple[int, int]]]:
    """
    SVG (y down) -> font (y up), baseline at y=0, then:
    - resample each contour to resample_n points
    - rotate startpoint to minimal (x,y)
    - sort contours stably (outer before inner, etc.)
    """
    contours_fc: List[List[Tuple[float, float]]] = []

    for pts in contours_svg:
        if len(pts) < 3:
            continue
        tpts = [(x, baseline_svg - y) for x, y in pts]  # y-down -> y-up
        if resample_n > 0:
            tpts = _resample_closed_contour(tpts, resample_n)
        tpts = _rotate_to_min_xy(tpts)
        contours_fc.append(tpts)

    sortable: List[Tuple[float, float, float, List[Tuple[float, float]]]] = []
    for pts in contours_fc:
        area = _poly_area(pts)
        cx, cy = _poly_centroid(pts)
        sortable.append((abs(area), cx, cy, pts))

    sortable.sort(key=lambda t: (-t[0], t[1], t[2]))

    out: List[List[Tuple[int, int]]] = []
    for _abs_area, _cx, _cy, pts in sortable:
        out.append([(int(round(x)), int(round(y))) for x, y in pts])

    return out


def bbox_from_contours(contours_fc: List[List[Tuple[int, int]]]) -> Tuple[int, int, int, int]:
    xs: List[int] = []
    ys: List[int] = []
    for c in contours_fc:
        for x, y in c:
            xs.append(x); ys.append(y)
    if not xs:
        return (0, 0, 0, 0)
    return (min(xs), min(ys), max(xs), max(ys))


def draw_contours_to_glyph(contours_fc: List[List[Tuple[int, int]]]) -> object:
    pen = TTGlyphPen(None)
    for pts in contours_fc:
        if len(pts) < 3:
            continue
        pen.moveTo(pts[0])
        for p in pts[1:]:
            pen.lineTo(p)
        pen.closePath()
    return pen.glyph()


def mean_int(xs: Iterable[int]) -> int:
    xs = list(xs)
    return int(round(sum(xs) / max(1, len(xs))))


def collect_inventory(svg_dir: Path) -> Tuple[List[str], Dict[int, str], List[Tuple[List[str], str]]]:
    """
    Determines glyph_order, cmap, ligatures based on filenames in svg_dir.
    """
    svg_files = sorted(svg_dir.glob("character-*.svg"))
    if not svg_files:
        raise SystemExit(f"[err] No glyph SVGs found in {svg_dir}/character-*.svg")

    glyph_order: List[str] = [".notdef", "space"]
    cmap: Dict[int, str] = {0x20: "space"}
    ligatures: List[Tuple[List[str], str]] = []

    for svg_path in svg_files:
        cps = parse_codepoints_from_filename(svg_path.name)
        if not cps:
            continue
        if len(cps) == 1:
            gname = glyph_name_for_codepoint(cps[0])
            if gname not in glyph_order:
                glyph_order.append(gname)
            cmap[cps[0]] = gname
        else:
            gname = ligature_name(cps)
            if gname not in glyph_order:
                glyph_order.append(gname)
            comps = [glyph_name_for_codepoint(cp) for cp in cps]
            ligatures.append((comps, gname))

    return glyph_order, cmap, ligatures


def compute_spacing_plan(
    master_svg_dirs: List[Path],
    glyph_order: List[str],
    baseline_svg: float,
    resample: int,
    sb_base: int,
    sb_scale: float,
    sb_min: int,
    sb_max: int,
    tracking: int,
    space_width: int,
) -> Dict[str, Tuple[int, int]]:
    """
    Returns spacing_plan[gname] = (advanceWidth, leftSideBearing)

    Uses MAX outline width across masters (so VF metrics stay stable).
    Outlines are later shifted per-master so xMin == lsb.
    """

    def sb_for_width(w: int) -> int:
        sb = int(round(sb_base + sb_scale * float(w)))
        sb = max(sb, sb_min)
        sb = min(sb, sb_max)
        return sb

    max_w: Dict[str, int] = {g: 0 for g in glyph_order}

    for svg_dir in master_svg_dirs:
        svg_files = sorted(svg_dir.glob("character-*.svg"))
        by_name: Dict[str, Path] = {}
        for p in svg_files:
            gname = glyph_name_from_filename(p.name)
            if gname:
                by_name[gname] = p

        for g in glyph_order:
            if g in (".notdef", "space"):
                continue
            p = by_name.get(g)
            if not p:
                continue

            _vb_w, _vb_h, d = parse_svg_viewbox_and_path(p)
            if not d.strip():
                continue

            try:
                contours_svg = parse_svg_d_to_contours(d)
            except Exception:
                continue

            contours_fc = normalize_contours_to_fontcoords(
                contours_svg, baseline_svg=baseline_svg, resample_n=resample
            )
            xMin, _yMin, xMax, _yMax = bbox_from_contours(contours_fc)
            w = max(0, xMax - xMin)
            if w > max_w[g]:
                max_w[g] = w

    plan: Dict[str, Tuple[int, int]] = {}
    plan["space"] = (int(space_width), 0)
    plan[".notdef"] = (int(M.UPM * 0.6), 0)

    for g in glyph_order:
        if g in (".notdef", "space"):
            continue
        w = max_w.get(g, 0)
        sb = sb_for_width(w)
        adv = int(round(w + 2 * sb + tracking))
        adv = max(adv, sb * 2 + 120)  # sane minimum even for empty glyphs
        plan[g] = (adv, sb)

    return plan


def build_ttf_from_svg_dir(
    svg_dir: Path,
    family: str,
    style: str,
    version: str,
    filename_base: str,
    baseline_svg: float,
    linegap: int,
    space_width: int,
    weight_class: int,
    resample: int,
    spacing_plan: Optional[Dict[str, Tuple[int, int]]] = None,
    force_glyph_order_from: Optional[List[str]] = None,
    force_cmap_from: Optional[Dict[int, str]] = None,
    force_liga_from: Optional[List[Tuple[List[str], str]]] = None,
) -> Tuple["fontTools.ttLib.TTFont", List[str], Dict[int, str], List[Tuple[List[str], str]], Dict[str, int]]:
    """
    Build a static master TTF from a directory of character-*.svg files.
    Returns:
      - TTFont
      - glyph_order
      - cmap
      - ligatures
      - contour_counts per glyph
    """
    svg_files = sorted(svg_dir.glob("character-*.svg"))
    if not svg_files:
        raise SystemExit(f"[err] No glyph SVGs found in {svg_dir}/character-*.svg")

    if force_glyph_order_from is not None and force_cmap_from is not None and force_liga_from is not None:
        glyph_order = list(force_glyph_order_from)
        cmap = dict(force_cmap_from)
        ligatures = list(force_liga_from)
    else:
        glyph_order, cmap, ligatures = collect_inventory(svg_dir)

    # Map glyph name -> svg file in this master
    by_name: Dict[str, Path] = {}
    for p in svg_files:
        gname = glyph_name_from_filename(p.name)
        if gname:
            by_name[gname] = p

    glyf: Dict[str, object] = {}
    hmtx: Dict[str, Tuple[int, int]] = {}
    contour_counts: Dict[str, int] = {}

    # .notdef
    empty_pen = TTGlyphPen(None)
    glyf[".notdef"] = empty_pen.glyph()
    hmtx[".notdef"] = (int(M.UPM * 0.6), 0)
    contour_counts[".notdef"] = 0

    # space
    space_pen = TTGlyphPen(None)
    glyf["space"] = space_pen.glyph()
    hmtx["space"] = (int(space_width), 0)
    contour_counts["space"] = 0

    global_xmin = 0
    global_ymin = 0
    global_xmax = 0
    global_ymax = 0
    have_bbox = False

    advances_for_avg: List[int] = []

    for gname in glyph_order:
        if gname in (".notdef", "space"):
            continue

        svg_path = by_name.get(gname)
        if not svg_path:
            adv, lsb = (spacing_plan.get(gname, (int(M.UPM * 0.5), 0)) if spacing_plan else (int(M.UPM * 0.5), 0))
            gp = TTGlyphPen(None)
            glyf[gname] = gp.glyph()
            hmtx[gname] = (int(adv), int(lsb))
            contour_counts[gname] = 0
            advances_for_avg.append(int(adv))
            continue

        vb_w, _vb_h, d = parse_svg_viewbox_and_path(svg_path)

        contours_svg: List[List[Tuple[float, float]]] = []
        if d.strip():
            try:
                contours_svg = parse_svg_d_to_contours(d)
            except Exception:
                contours_svg = []

        contours_fc = normalize_contours_to_fontcoords(contours_svg, baseline_svg=baseline_svg, resample_n=resample)
        xMin, yMin, xMax, yMax = bbox_from_contours(contours_fc)
        ncont = len(contours_fc)

        # Determine target metrics
        if spacing_plan and gname in spacing_plan:
            adv, lsb = spacing_plan[gname]
        else:
            # Fallback: use SVG viewBox width as advance, but keep consistent LSB
            adv = int(round(vb_w))
            lsb = int(xMin)

        # Shift outline so xMin == lsb
        dx = int(lsb) - int(xMin)
        if dx != 0 and contours_fc:
            contours_fc = [[(x + dx, y) for (x, y) in c] for c in contours_fc]
            xMin += dx
            xMax += dx

        glyph = draw_contours_to_glyph(contours_fc)
        glyf[gname] = glyph
        hmtx[gname] = (int(adv), int(lsb))
        contour_counts[gname] = ncont
        advances_for_avg.append(int(adv))

        if not have_bbox:
            global_xmin, global_ymin, global_xmax, global_ymax = xMin, yMin, xMax, yMax
            have_bbox = True
        else:
            global_xmin = min(global_xmin, xMin)
            global_ymin = min(global_ymin, yMin)
            global_xmax = max(global_xmax, xMax)
            global_ymax = max(global_ymax, yMax)

    # Vertical metrics
    asc = max(int(M.BASE - M.CAP_TOP), global_ymax)
    desc = min(-int(M.DESC_END - M.BASE), global_ymin)  # negative

    fb = FontBuilder(M.UPM, isTTF=True)
    fb.setupGlyphOrder(glyph_order)
    fb.setupGlyf(glyf)
    fb.setupHorizontalMetrics(hmtx)
    fb.setupHorizontalHeader(ascent=asc, descent=desc, lineGap=int(linegap))
    fb.setupMaxp()
    fb.setupPost(formatType=3.0)

    fb.setupHead(
        unitsPerEm=M.UPM,
        fontRevision=float(version),
        xMin=int(global_xmin),
        yMin=int(global_ymin),
        xMax=int(global_xmax),
        yMax=int(global_ymax),
    )

    # IMPORTANT: cmap before OS/2
    fb.setupCharacterMap(cmap)

    xheight = int(round(M.XH))
    capheight = int(round(M.BASE - M.CAP_TOP))
    avg_w = mean_int(advances_for_avg) if advances_for_avg else int(M.UPM * 0.5)

    fb.setupOS2(
        sTypoAscender=asc,
        sTypoDescender=desc,
        sTypoLineGap=int(linegap),
        usWinAscent=max(0, asc),
        usWinDescent=max(0, -desc),
        sxHeight=xheight,
        sCapHeight=capheight,
        xAvgCharWidth=avg_w,
        usWeightClass=int(weight_class),
        usWidthClass=5,
    )

    full_name = f"{family} {style}".strip()
    ps_name = re.sub(r"[^A-Za-z0-9-]", "", full_name.replace(" ", "-"))[:63] or f"{filename_base}-{style}"

    fb.setupNameTable(
        {
            "familyName": family,
            "styleName": style,
            "fullName": full_name,
            "psName": ps_name,
            "version": f"Version {version}",
        }
    )

    font = fb.font

    # liga substitutions
    if ligatures:
        fea_lines = [
            "languagesystem DFLT dflt;",
            "languagesystem latn dflt;",
            "",
            "feature liga {",
        ]
        added = 0
        for comps, lig in ligatures:
            if all(c in glyf for c in comps) and lig in glyf:
                fea_lines.append(f"  sub {' '.join(comps)} by {lig};")
                added += 1
        fea_lines.append("} liga;")
        if added:
            addOpenTypeFeaturesFromString(font, "\n".join(fea_lines) + "\n")

    return font, glyph_order, cmap, ligatures, contour_counts


def save_font_with_formats(font, base_path: Path, formats: List[str]) -> None:
    wrote_any = False
    for fmt in formats:
        fmt = fmt.lower()
        if fmt == "ttf":
            out_path = base_path.with_suffix(".ttf")
            font.flavor = None
        elif fmt == "woff":
            out_path = base_path.with_suffix(".woff")
            font.flavor = "woff"
        elif fmt == "woff2":
            out_path = base_path.with_suffix(".woff2")
            font.flavor = "woff2"
        else:
            continue

        try:
            font.save(out_path)
            print(f"Wrote: {out_path}")
            wrote_any = True
        except Exception as e:
            print(f"[warn] Could not write {out_path.name}: {e}", file=sys.stderr)

    if not wrote_any:
        raise SystemExit(1)


def main() -> None:
    ap = argparse.ArgumentParser()

    # Backwards-compatible I/O
    ap.add_argument("--in", dest="in_dir", type=Path, default=Path("sketches"))
    ap.add_argument("--out", dest="out_dir", type=Path, default=Path("dist/fonts"))
    ap.add_argument("--family", type=str, default="Ligatureluurs")
    ap.add_argument("--style", type=str, default="Regular")
    ap.add_argument("--version", type=str, default="1.0")
    ap.add_argument("--formats", nargs="+", default=["ttf", "woff", "woff2"], choices=["ttf", "woff", "woff2"])
    ap.add_argument("--filename", type=str, default="ligatureluurs", help="Base filename without extension")
    ap.add_argument("--space-width", type=int, default=300)
    ap.add_argument("--baseline", type=float, default=M.BASE, help="SVG baseline y to map to font y=0")
    ap.add_argument("--linegap", type=int, default=200)

    # Variable-font controls
    ap.add_argument("--static", action="store_true", help="Build a single static font from --in (old behavior).")

    ap.add_argument("--glyph-script", type=Path, default=DEFAULT_GLYPH_SCRIPT,
                    help="Path to tools/generate-svg.py (assumed by default).")
    ap.add_argument("--chars", type=str, default="", help="Optional: pass through to glyph generator.")
    ap.add_argument("--resolution", type=int, default=64, help="Pass through to glyph generator.")

    # 3 masters: thin / regular / bold
    ap.add_argument("--strokes", nargs=3, type=float, default=[70.0, 90.0, 120.0],
                    metavar=("THIN", "REG", "BOLD"),
                    help="Stroke widths for the 3 masters.")
    ap.add_argument("--weights", nargs=3, type=int, default=[200, 400, 900],
                    metavar=("THIN", "REG", "BOLD"),
                    help="wght axis values for the 3 masters.")

    ap.add_argument("--resample", type=int, default=192,
                    help="Resample every contour to N points (required for stable interpolation).")
    ap.add_argument("--build-dir", type=Path, default=Path("build/vf"),
                    help="Where master SVGs/TTFs and the designspace are written.")
    ap.add_argument("--no-generate", action="store_true",
                    help="Do NOT call tools/generate-svg.py; assume master SVG dirs already exist in build-dir.")

    # Spacing tuning (optional)
    ap.add_argument("--tracking", type=int, default=0, help="Add to every advance width (can be negative).")
    ap.add_argument("--sb-base", type=int, default=60, help="Base sidebearing (units).")
    ap.add_argument("--sb-scale", type=float, default=0.06, help="Extra SB proportional to glyph width.")
    ap.add_argument("--sb-min", type=int, default=55, help="Minimum sidebearing clamp.")
    ap.add_argument("--sb-max", type=int, default=130, help="Maximum sidebearing clamp.")

    args = ap.parse_args()

    out_dir: Path = args.out_dir
    out_dir.mkdir(parents=True, exist_ok=True)
    base_out = out_dir / args.filename

    css_out = out_dir / f"{args.filename}.css"
    css_src = SRC_CSS_DEFAULT

    # -------------------------
    # Static mode (single font)
    # -------------------------
    if args.static:
        glyph_order, cmap, ligatures = collect_inventory(args.in_dir)
        plan = compute_spacing_plan(
            master_svg_dirs=[args.in_dir],
            glyph_order=glyph_order,
            baseline_svg=float(args.baseline),
            resample=0,
            sb_base=int(args.sb_base),
            sb_scale=float(args.sb_scale),
            sb_min=int(args.sb_min),
            sb_max=int(args.sb_max),
            tracking=int(args.tracking),
            space_width=int(args.space_width),
        )

        font, _go, _cmap, _liga, _cc = build_ttf_from_svg_dir(
            svg_dir=args.in_dir,
            family=args.family,
            style=args.style,
            version=args.version,
            filename_base=args.filename,
            baseline_svg=float(args.baseline),
            linegap=int(args.linegap),
            space_width=int(args.space_width),
            weight_class=400,
            resample=0,
            spacing_plan=plan,
            force_glyph_order_from=glyph_order,
            force_cmap_from=cmap,
            force_liga_from=ligatures,
        )
        save_font_with_formats(font, base_out, args.formats)
        write_css_bundle(css_out, css_src)
        return

    # -------------------------
    # Variable mode (default)
    # -------------------------
    glyph_script: Path = args.glyph_script
    if not glyph_script.exists():
        raise SystemExit(f"[err] Missing glyph generator at: {glyph_script}")

    build_dir: Path = args.build_dir
    build_dir.mkdir(parents=True, exist_ok=True)

    strokes = list(map(float, args.strokes))
    weights = list(map(int, args.weights))
    styles  = ["Thin", "Regular", "Bold"]

    master_svg_dirs: List[Path] = [build_dir / f"svg-{w}" for w in weights]
    master_ttf_paths: List[Path] = [build_dir / f"master-{w}.ttf" for w in weights]

    # 1) Generate master SVGs (unless disabled)
    if not args.no_generate:
        for svg_dir, stroke in zip(master_svg_dirs, strokes):
            svg_dir.mkdir(parents=True, exist_ok=True)
            cmd = [
                sys.executable, str(glyph_script),
                "--out", str(svg_dir),
                "--stroke", str(stroke),
                "--resolution", str(int(args.resolution)),
            ]
            if args.chars:
                cmd += ["--chars", args.chars]
            run(cmd)

    # 2) Use Regular master inventory for stable glyph order/maps
    regular_idx = 1
    glyph_order, cmap, ligatures = collect_inventory(master_svg_dirs[regular_idx])

    # 3) Compute spacing plan based on MAX outline widths across masters
    plan = compute_spacing_plan(
        master_svg_dirs=master_svg_dirs,
        glyph_order=glyph_order,
        baseline_svg=float(args.baseline),
        resample=int(args.resample),
        sb_base=int(args.sb_base),
        sb_scale=float(args.sb_scale),
        sb_min=int(args.sb_min),
        sb_max=int(args.sb_max),
        tracking=int(args.tracking),
        space_width=int(args.space_width),
    )

    # 4) Build masters (same glyph order/maps/spacing plan)
    all_counts: List[Dict[str, int]] = []
    for idx in range(3):
        f, _go, _cmap, _liga, cc = build_ttf_from_svg_dir(
            svg_dir=master_svg_dirs[idx],
            family=args.family,
            style=styles[idx],
            version=args.version,
            filename_base=args.filename,
            baseline_svg=float(args.baseline),
            linegap=int(args.linegap),
            space_width=int(args.space_width),
            weight_class=weights[idx],
            resample=int(args.resample),
            spacing_plan=plan,
            force_glyph_order_from=glyph_order,
            force_cmap_from=cmap,
            force_liga_from=ligatures,
        )
        f.save(master_ttf_paths[idx])
        print(f"Wrote master: {master_ttf_paths[idx]}")
        all_counts.append(cc)

    # 5) Compatibility check: contour count must match across masters
    bad: List[str] = []
    for gname in glyph_order:
        c0 = all_counts[0].get(gname, 0)
        c1 = all_counts[1].get(gname, 0)
        c2 = all_counts[2].get(gname, 0)
        if not (c0 == c1 == c2):
            bad.append(f"{gname}: contours thin/reg/bold = {c0}/{c1}/{c2}")

    if bad:
        print("\n[err] Masters are not interpolatable: some glyphs change contour topology between weights.\n"
              "This is common when strokes merge/separate with Shapely buffering.\n"
              "Fix by narrowing the stroke range (or adjusting glyph construction so joins stay consistent).\n",
              file=sys.stderr)
        for line in bad[:80]:
            print("  -", line, file=sys.stderr)
        if len(bad) > 80:
            print(f"  ... and {len(bad) - 80} more", file=sys.stderr)
        raise SystemExit(2)

    # 6) Write designspace
    ds_path = build_dir / f"{args.filename}.designspace"
    ds = DesignSpaceDocument()

    axis = AxisDescriptor()
    axis.name = "Weight"
    axis.tag = "wght"
    axis.minimum = float(min(weights))
    axis.default = float(weights[regular_idx])
    axis.maximum = float(max(weights))
    ds.addAxis(axis)

    axis_name = axis.name  # locations use axis.name

    for idx, (w, style, ttf_path) in enumerate(zip(weights, styles, master_ttf_paths)):
        src = SourceDescriptor()
        src.name = f"master_{w}"
        src.familyName = args.family
        src.styleName = style
        src.path = str(ttf_path)
        src.location = {axis_name: float(w)}
        if idx == regular_idx:
            src.copyInfo = True
            src.copyLib = True
            src.copyFeatures = True
            src.copyGroups = True
        ds.addSource(src)

    ds.write(ds_path)
    print(f"Wrote designspace: {ds_path}")

    # 7) Build variable font
    vf, _model, _master_ttfs = var_build(str(ds_path))

    # 8) Save VF to dist/fonts/ligatureluurs.{ext}
    save_font_with_formats(vf, base_out, args.formats)

    # 9) Copy CSS bundle
    write_css_bundle(css_out, css_src)


if __name__ == "__main__":
    main()
